<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PTG - Blind Test üéµ</title>
    <link href="https://fonts.googleapis.com/css2?family=Bungee+Shade&family=Montserrat:wght@600;800&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Montserrat', sans-serif;
            background: #0a0e27;
            color: white;
            min-height: 100vh;
        }

        .app { min-height: 100vh; position: relative; }

        .bg {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: 
                radial-gradient(circle at 20% 50%, rgba(255, 0, 110, 0.1), transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(131, 56, 236, 0.1), transparent 50%);
            animation: pulse 8s infinite;
            z-index: 0;
        }

        @keyframes pulse { 0%, 100% { opacity: 0.5; } 50% { opacity: 0.8; } }

        .screen {
            position: relative;
            z-index: 1;
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem 1rem;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding-top: 3rem;
        }

        .hidden { display: none !important; }

        /* MENU */
        .logo { text-align: center; margin-bottom: 2rem; }
        .title {
            font-family: 'Bungee Shade', cursive;
            font-size: 4rem;
            background: linear-gradient(45deg, #ff006e, #00f5ff, #ffbe0b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .subtitle {
            font-size: 1.2rem;
            color: #00f5ff;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            margin-top: 0.5rem;
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            width: 100%;
            max-width: 400px;
        }

        /* BUTTONS */
        .btn {
            background: linear-gradient(135deg, #ff006e, #8338ec);
            color: white;
            border: none;
            padding: 0.8rem 1.5rem;
            font-size: 1rem;
            font-weight: 800;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Montserrat', sans-serif;
            margin: 0.3rem;
        }

        .btn:hover:not(:disabled) { transform: translateY(-3px); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn.large { padding: 1.5rem 3rem; font-size: 1.3rem; }
        .btn.secondary { background: linear-gradient(135deg, #00f5ff, #ffbe0b); }
        .btn.danger { background: linear-gradient(135deg, #ff006e, #ff4444); }

        /* INPUTS */
        .input, .select {
            width: 100%;
            max-width: 400px;
            padding: 1rem;
            margin: 0.5rem auto;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid #8338ec;
            border-radius: 10px;
            color: white;
            font-size: 1rem;
            font-family: 'Montserrat', sans-serif;
            display: block;
        }

        .input::placeholder { color: rgba(255, 255, 255, 0.5); }
        .input:focus, .select:focus { outline: none; border-color: #ff006e; }
        .code-input { font-size: 2rem; text-align: center; letter-spacing: 0.5em; }

        /* SECTIONS */
        .section { margin: 1.5rem 0; text-align: center; width: 100%; max-width: 500px; }
        .section h3 { color: #00f5ff; margin-bottom: 1rem; }

        .num-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 0.5rem;
            max-width: 400px;
            margin: 0 auto;
        }

        .num-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid #8338ec;
            color: white;
            padding: 0.8rem;
            font-size: 1.1rem;
            font-weight: 800;
            border-radius: 10px;
            cursor: pointer;
            font-family: 'Montserrat', sans-serif;
            transition: all 0.2s;
        }

        .num-btn:hover { background: rgba(255, 255, 255, 0.1); }
        .num-btn.active { background: linear-gradient(135deg, #ff006e, #8338ec); border-color: #ff006e; }

        /* CHECKBOX */
        .checkbox-label {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            cursor: pointer;
            margin: 0.5rem 0;
            padding: 0.8rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            transition: all 0.3s;
        }

        .checkbox-label:hover { background: rgba(0, 0, 0, 0.4); }

        .checkbox-label input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .checkbox-label span {
            color: #00f5ff;
            font-weight: 600;
        }

        /* PLAYLISTS */
        .playlists-box {
            background: #1a1f3a;
            border: 2px solid #8338ec;
            border-radius: 20px;
            padding: 1.5rem;
            width: 100%;
            max-width: 600px;
            margin: 1rem 0;
        }

        .playlist-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 1rem;
            border-radius: 10px;
            margin-bottom: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
        }

        .playlist-name {
            flex: 1;
            font-weight: 600;
            color: #ffbe0b;
        }

        .playlist-url {
            flex: 2;
            font-size: 0.8rem;
            color: #aaa;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* LOBBY */
        .code-display {
            text-align: center;
            background: linear-gradient(135deg, #1a1f3a, #2a2f4a);
            border: 3px solid #ffbe0b;
            border-radius: 20px;
            padding: 1rem 1.5rem;
            margin-bottom: 1rem;
            box-shadow: 0 10px 40px rgba(255, 190, 11, 0.3);
        }

        .code-label { color: #aaa; font-size: 0.9rem; margin-bottom: 0.5rem; }
        .code-value {
            font-size: 3rem;
            font-weight: 800;
            color: #ffbe0b;
            letter-spacing: 0.2em;
            text-shadow: 0 0 30px rgba(255, 190, 11, 0.6);
        }

        .players-box {
            background: #1a1f3a;
            border: 2px solid #8338ec;
            border-radius: 20px;
            padding: 1rem;
            width: 100%;
            max-width: 95%;
            margin-bottom: 1rem;
        }

        .players-box h3 { color: #00f5ff; margin-bottom: 0.5rem; font-size: 1.2rem; text-align: center; }

        /* Conteneur en grille pour afficher les joueurs horizontalement */
        #players-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 0.5rem;
            max-height: 45vh;
            overflow-y: auto;
            padding: 0.3rem;
        }

        .player {
            background: rgba(0, 0, 0, 0.3);
            padding: 0.5rem 0.7rem;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 0.6rem;
        }

        .player-num {
            background: #8338ec;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 800;
            font-size: 0.85rem;
            flex-shrink: 0;
        }

        .player-name { 
            flex: 1; 
            font-weight: 600; 
            font-size: 0.9rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .waiting { text-align: center; margin-top: 2rem; }
        .waiting p { font-size: 1.2rem; color: #ffbe0b; margin-top: 1rem; }

        .spinner {
            width: 60px;
            height: 60px;
            border: 5px solid rgba(255, 255, 255, 0.1);
            border-top-color: #ff006e;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin { to { transform: rotate(360deg); } }

        /* GAME */
        .game-header {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 800px;
            margin-bottom: 1.5rem;
            background: #1a1f3a;
            padding: 1rem 1.5rem;
            border-radius: 15px;
            border: 2px solid #8338ec;
            font-weight: 800;
        }

        .timer { color: #ff006e; font-size: 1.3rem; }
        .score { color: #ffbe0b; font-size: 1.3rem; }

        .game-container {
            display: flex;
            gap: 2rem;
            width: 100%;
            max-width: 1200px;
            align-items: flex-start;
            justify-content: center;
        }

        .game-main {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 700px;
        }

        .scoreboard-side {
            width: 250px;
            background: #1a1f3a;
            border: 2px solid #8338ec;
            border-radius: 20px;
            padding: 1.5rem;
            position: sticky;
            top: 20px;
        }

        .scoreboard-side h3 {
            color: #00f5ff;
            margin-bottom: 1rem;
            text-align: center;
        }

        .score-item {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem;
            margin-bottom: 0.5rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            font-size: 0.9rem;
        }

        .score-item.me {
            background: rgba(255, 190, 11, 0.2);
            border: 1px solid #ffbe0b;
        }

        .score-name { font-weight: 600; }
        .score-points { color: #ffbe0b; font-weight: 800; }

        .img-box {
            width: 100%;
            max-width: 400px;
            margin: 0 auto 1.5rem;
            border-radius: 20px;
            overflow: hidden;
        }

        .cover {
            width: 100%;
            height: 400px;
            object-fit: cover;
            transition: filter 0.3s ease, opacity 0.3s ease;
        }

        .answer-reveal {
            text-align: center;
            margin-top: 1rem;
            padding: 1.5rem;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            border: 2px solid #00f5ff;
        }

        .answer-reveal h4 {
            color: #00f5ff;
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
        }

        .answer-reveal .answer-text {
            color: #ffbe0b;
            font-size: 1.8rem;
            font-weight: 800;
        }

        .audio-box { text-align: center; margin: 1rem 0; }

        .audio-btn {
            background: linear-gradient(135deg, #ffbe0b, #ff006e);
            color: white;
            border: none;
            padding: 0.8rem 2rem;
            font-size: 1rem;
            font-weight: 800;
            border-radius: 50px;
            cursor: pointer;
            font-family: 'Montserrat', sans-serif;
        }

        .question-box { width: 100%; max-width: 600px; margin: 0 auto; }

        .q-text {
            text-align: center;
            font-size: 1.5rem;
            font-weight: 800;
            color: #00f5ff;
            margin-bottom: 1.5rem;
            word-wrap: break-word;
            padding: 0 0.5rem;
        }

        .options {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .opt {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid #8338ec;
            padding: 1.5rem 1rem;
            border-radius: 15px;
            color: white;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.3s;
            word-wrap: break-word;
            text-align: center;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .opt:hover { background: rgba(131, 56, 236, 0.2); transform: scale(1.05); }
        .opt.correct { background: rgba(0, 255, 100, 0.2); border-color: #00ff64; }
        .opt.wrong { background: rgba(255, 0, 0, 0.2); border-color: #ff0033; }
        .opt.disabled { cursor: not-allowed; opacity: 0.6; }

        .result {
            margin-top: 1.5rem;
            padding: 1.5rem;
            border-radius: 15px;
            text-align: center;
            font-size: 1.3rem;
            font-weight: 800;
        }

        .result.correct { background: rgba(0, 255, 100, 0.2); border: 2px solid #00ff64; color: #00ff64; }
        .result.wrong { background: rgba(255, 0, 0, 0.2); border: 2px solid #ff0033; color: #ff6b6b; }

        /* LEADERBOARD */
        .leaderboard-title {
            font-size: 2rem;
            font-weight: 800;
            color: #ffbe0b;
            margin-bottom: 1rem;
            text-shadow: 0 0 20px rgba(255, 190, 11, 0.5);
        }

        .podium {
            display: flex;
            gap: 0.8rem;
            justify-content: center;
            align-items: flex-end;
            margin: 1rem 0;
            flex-wrap: wrap;
        }

        .podium-item {
            background: #1a1f3a;
            border: 3px solid #8338ec;
            border-radius: 15px;
            padding: 1rem 1rem;
            text-align: center;
            min-width: 120px;
            transition: all 0.3s;
        }
        
        /* 1er place - Le plus grand au centre */
        .podium-item.first {
            order: 2;
            transform: scale(1.1);
            border-color: #ffbe0b;
            box-shadow: 0 0 30px rgba(255, 190, 11, 0.4);
            padding: 1.3rem 1.2rem;
        }
        
        /* 2√®me place - Moyen √† gauche */
        .podium-item.second {
            order: 1;
            transform: scale(1.03);
            border-color: #00f5ff;
        }
        
        /* 3√®me place - Plus petit √† droite */
        .podium-item.third {
            order: 3;
            transform: scale(0.97);
            border-color: #ff006e;
        }

        .medal { font-size: 2rem; margin-bottom: 0.3rem; }
        .p-name { 
            font-weight: 800; 
            font-size: 1rem; 
            color: #ffbe0b; 
            margin: 0.3rem 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .p-score { font-size: 1.2rem; font-weight: 800; color: #ff006e; }

        .leaderboard {
            background: #1a1f3a;
            border: 2px solid #8338ec;
            border-radius: 20px;
            padding: 1rem;
            width: 100%;
            max-width: 95%;
            margin: 1rem auto;
            max-height: 45vh;
            overflow-y: auto;
        }
        
        /* Conteneur en grille pour les lb-row */
        .leaderboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 0.4rem;
        }

        .lb-row {
            display: flex;
            align-items: center;
            gap: 0.6rem;
            padding: 0.4rem 0.6rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }

        .rank {
            background: #8338ec;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 800;
            font-size: 0.9rem;
            flex-shrink: 0;
        }

        .name { 
            flex: 1; 
            font-weight: 600; 
            font-size: 0.95rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .pts { 
            font-weight: 800; 
            color: #ffbe0b; 
            font-size: 1rem;
            flex-shrink: 0;
        }

        /* LOADING */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        .loading-text {
            color: #ffbe0b;
            font-size: 1.5rem;
            font-weight: 800;
            margin-top: 2rem;
        }

        /* BOUTON SECOURS */
        .emergency-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 0, 0, 0.8);
            color: white;
            border: none;
            padding: 1rem 1.5rem;
            border-radius: 50px;
            cursor: pointer;
            font-weight: 800;
            z-index: 9999;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            font-family: 'Montserrat', sans-serif;
        }

        /* BADGES MODE √âCRITURE */
        .writing-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.6rem 1rem;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid #8338ec;
            border-radius: 10px;
            font-weight: 700;
            font-size: 0.9rem;
            transition: all 0.3s;
        }

        .writing-badge.found {
            background: rgba(0, 255, 100, 0.2);
            border-color: #00ff64;
        }

        .badge-icon {
            font-size: 1.2rem;
        }

        .badge-label {
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .badge-status {
            font-size: 1.1rem;
            color: #ff0033;
        }

        .writing-badge.found .badge-status {
            color: #00ff64;
        }

        @media (max-width: 768px) {
            .screen {
                padding: 1.5rem 0.75rem;
                padding-top: 2rem;
            }
            .title { 
                font-size: 2.5rem; 
            }
            .subtitle {
                font-size: 0.9rem;
            }
            .game-header {
                flex-direction: column;
                gap: 0.5rem;
                padding: 1rem;
                text-align: center;
            }
            .timer, .score {
                font-size: 1.1rem;
            }
            .options { 
                grid-template-columns: 1fr; 
                gap: 0.75rem;
            }
            .opt {
                padding: 1.2rem 0.8rem;
                font-size: 0.95rem;
            }
            .cover { 
                height: 280px; 
            }
            .img-box {
                max-width: 100%;
                margin-bottom: 1rem;
            }
            .q-text {
                font-size: 1.2rem;
                padding: 0 0.25rem;
            }
            .code-value { 
                font-size: 3rem; 
            }
            .game-container { 
                flex-direction: column; 
            }
            .scoreboard-side { 
                width: 100%; 
                position: relative;
                order: -1;
                margin-bottom: 1rem;
            }
            .game-main {
                width: 100%;
            }
            .input, .select {
                font-size: 0.95rem;
                padding: 0.9rem;
            }
            .btn {
                font-size: 0.95rem;
                padding: 0.7rem 1.3rem;
            }
            .btn.large {
                padding: 1.2rem 2rem;
                font-size: 1.1rem;
            }
            .menu-buttons {
                padding: 0 1rem;
            }
            .writing-badge {
                font-size: 0.8rem;
                padding: 0.5rem 0.7rem;
            }
            .badge-icon {
                font-size: 1rem;
            }
        }

        @media (max-width: 480px) {
            .title {
                font-size: 2rem;
            }
            .subtitle {
                font-size: 0.8rem;
                letter-spacing: 0.1em;
            }
            .q-text {
                font-size: 1.1rem;
            }
            .opt {
                font-size: 0.9rem;
                padding: 1rem 0.6rem;
                min-height: 50px;
            }
            .cover {
                height: 250px;
            }
            .game-header {
                padding: 0.8rem;
                font-size: 0.9rem;
            }
            .timer, .score {
                font-size: 1rem;
            }
            .writing-badge {
                font-size: 0.75rem;
                padding: 0.4rem 0.6rem;
                gap: 0.3rem;
            }
            .badge-icon {
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>
    <div class="app">
        <div class="bg"></div>

        <!-- LOADING -->
        <div id="loading-overlay" class="loading-overlay hidden">
            <div class="spinner"></div>
            <div class="loading-text" id="loading-text">Chargement...</div>
        </div>

        <!-- MENU -->
        <div id="menu-screen" class="screen">
            <div class="logo">
                <img src="logo.png" alt="logo" style="height: 200px; width: auto; display: block; margin: 0 auto 0.5rem;">
                <h1 class="title" style="margin: 0;">BLIND TEST</h1>
                <p class="subtitle">BY PLAY THAU'GETHER</p>
            </div>
            <div class="menu-buttons">
                <button class="btn large" onclick="goToCreate()">üéÆ Cr√©er une partie</button>
                <button class="btn large secondary" onclick="goToJoin()">üë• Rejoindre une partie</button>
                <button class="btn" onclick="goToPlaylists()">üìã G√©rer Playlists</button>
            </div>
        </div>

        <!-- PLAYLISTS -->
        <div id="playlists-screen" class="screen hidden">
            <h2 style="font-size: 2.5rem; color: #ffbe0b; margin-bottom: 2rem;">üìã G√©rer mes Playlists</h2>
            
            <!-- PLAYLISTS DEEZER -->
            <div class="playlists-box" style="margin-bottom: 2rem;">
                <h3 style="color: #00f5ff; margin-bottom: 1rem;">üéµ Playlists Deezer</h3>
                <div id="playlists-list"></div>
                <button class="btn" onclick="showAddPlaylist()" style="margin-top: 1rem;">‚ûï Ajouter une playlist Deezer</button>
            </div>

            <!-- PLAYLISTS JSON -->
            <div class="playlists-box">
                <h3 style="color: #00f5ff; margin-bottom: 1rem;">üìö Mes Playlists JSON</h3>
                <div id="json-playlists-list"></div>
                <p id="no-json-playlists" style="color: #aaa; font-size: 0.9rem; margin-top: 0.5rem;">
                    Aucune playlist JSON sauvegard√©e. Cr√©ez-en une dans "Cr√©er une partie" ‚Üí Onglet "üé® Nouvelle Playlist".
                </p>
            </div>

            <div id="add-playlist-form" class="section hidden">
                <h3>Nouvelle Playlist Deezer</h3>
                <input id="new-playlist-name" class="input" placeholder="Nom de la playlist">
                <input id="new-playlist-url" class="input" placeholder="URL Deezer">
                <button class="btn" onclick="savePlaylist()">üíæ Enregistrer</button>
            </div>

            <button class="btn" onclick="goToMenu()" style="margin-top: 2rem;">üè† Retour</button>
        </div>

        <!-- CREATE -->
        <div id="create-screen" class="screen hidden">
            <h2 style="font-size: 2.5rem; color: #ffbe0b; margin-bottom: 2rem;">üéÆ Cr√©er une partie</h2>
            
            <input id="create-name" class="input" placeholder="Ton pseudo" maxlength="20">
            
            <div class="section">
                <h3>üéØ Mode de jeu</h3>
                <select id="create-mode" class="select">
                    <option value="qcm">QCM (Choix multiples)</option>
                    <option value="writing">√âcriture (Titre + Artiste)</option>
                    <option value="title-only">Titres uniquement</option>
                    <option value="soiree">Soir√©e (Mix QCM + √âcriture)</option>
                    <option value="mix">üéß Mix (Normal ‚Üí Reverse ‚Üí Extrait)</option>
                    <option value="qcm-film">üé¨ QCM Film (Trouve le film)</option>
                </select>
            </div>

            <div class="section">
                <h3>‚öôÔ∏è Options</h3>
                <label class="checkbox-label">
                    <input type="checkbox" id="host-mode">
                    <span>Mode H√¥te (Affichage seulement)</span>
                </label>
                <label class="checkbox-label">
                    <input type="checkbox" id="distance-mode">
                    <span>Mode Distance (Son sur tous les appareils)</span>
                </label>
            </div>

            <div class="section">
                <h3>üî¢ Nombre de questions</h3>
                <div class="num-grid">
                    <button class="num-btn" onclick="selectNumQ(5)">5</button>
                    <button class="num-btn active" onclick="selectNumQ(10)">10</button>
                    <button class="num-btn" onclick="selectNumQ(15)">15</button>
                    <button class="num-btn" onclick="selectNumQ(20)">20</button>
                    <button class="num-btn" onclick="selectNumQ(30)">30</button>
                </div>
            </div>

            <div class="section">
                <h3>üéµ Choisir une playlist</h3>
                
                <!-- TABS -->
                <div style="display: flex; gap: 1rem; margin-bottom: 1rem;">
                    <button class="btn large" onclick="switchPlaylistTab('deezer')" id="tab-deezer" style="flex: 1; background: #ffbe0b;">
                        üéµ Deezer
                    </button>
                    <button class="btn large" onclick="switchPlaylistTab('saved')" id="tab-saved" style="flex: 1; background: rgba(255,255,255,0.1);">
                        üìö Mes Playlists
                    </button>
                    <button class="btn large" onclick="switchPlaylistTab('custom')" id="tab-custom" style="flex: 1; background: rgba(255,255,255,0.1);">
                        üé® Nouvelle Playlist
                    </button>
                </div>
                
                <!-- DEEZER TAB -->
                <div id="deezer-tab" style="display: block;">
                    <select id="playlist-select" class="select">
                        <option value="">-- S√©lectionner --</option>
                    </select>
                    <p style="margin-top: 0.5rem; font-size: 0.9rem; color: #aaa;">
                        Ou ajouter une URL personnalis√©e :
                    </p>
                    <input id="custom-playlist-url" class="input" placeholder="URL Playlist Deezer">
                </div>
                
                <!-- SAVED PLAYLISTS TAB -->
                <div id="saved-tab" style="display: none;">
                    <select id="saved-playlist-select" class="select" onchange="loadSavedPlaylist()">
                        <option value="">-- S√©lectionner une playlist sauvegard√©e --</option>
                    </select>
                    <div id="saved-playlist-actions" style="margin-top: 1rem; display: none;">
                        <button class="btn" style="background: #f56565; color: white;" onclick="deleteSavedPlaylist()">üóëÔ∏è Supprimer cette playlist</button>
                    </div>
                    <p style="margin-top: 1rem; font-size: 0.85rem; color: #aaa;" id="no-saved-playlists">
                        Aucune playlist sauvegard√©e. Cr√©ez-en une dans l'onglet "üé® Nouvelle Playlist" !
                    </p>
                </div>
                
                <!-- CUSTOM TAB -->
                <div id="custom-tab" style="display: none;">
                    <p style="margin-bottom: 1rem; font-size: 0.9rem; color: #aaa;">
                        üìù Colle le contenu de ton fichier JSON ici :
                    </p>
                    <textarea id="custom-json" class="input" placeholder='{"playlist": [{"title": "...", "artist": "...", "preview": "...", "cover": "..."}]}' style="min-height: 200px; font-family: monospace; font-size: 0.85rem; resize: vertical;"></textarea>
                    <p style="margin-top: 0.5rem; font-size: 0.85rem; color: #00f5ff;">
                        üí° Utilise le <a href="playlist-generator.html" target="_blank" style="color: #ffbe0b; font-weight: 600;">g√©n√©rateur JSON</a> pour cr√©er ta playlist facilement !
                    </p>
                    <button class="btn large" style="background: #48bb78; color: white; margin-top: 1rem; width: 100%;" onclick="saveCurrentPlaylist()">
                        üíæ Sauvegarder cette playlist pour plus tard
                    </button>
                </div>
                
                <button class="btn large" onclick="loadAndCreate()">üöÄ Cr√©er la partie</button>
            </div>

            <button class="btn" onclick="goToMenu()" style="margin-top: 2rem;">üè† Retour</button>
        </div>

        <!-- JOIN -->
        <div id="join-screen" class="screen hidden">
            <h2 style="font-size: 2.5rem; color: #ffbe0b; margin-bottom: 2rem;">üë• Rejoindre</h2>
            <input id="join-name" class="input" placeholder="Ton pseudo" maxlength="20">
            <input id="join-code" class="input code-input" placeholder="123456" type="tel" maxlength="6">
            <button class="btn large" onclick="joinRoom()">‚ñ∂Ô∏è Rejoindre</button>
            <button class="btn" onclick="goToMenu()" style="margin-top: 2rem;">üè† Retour</button>
        </div>

        <!-- LOBBY -->
        <div id="lobby-screen" class="screen hidden">
            <h2 style="font-size: 1.8rem; color: #ffbe0b; margin-bottom: 1rem;">Salle d'attente</h2>
            
            <div class="code-display">
                <div class="code-label">Code de la partie</div>
                <div class="code-value" id="lobby-code">000000</div>
            </div>
            
            <button id="change-code-btn" class="btn secondary hidden" onclick="changeRoomCode()" style="margin-top: 1rem;">
                üîÑ Changer le code pour les prochaines parties
            </button>

            <div class="players-box">
                <h3>üë• Joueurs (<span id="player-count">0</span>)</h3>
                <div id="players-list"></div>
            </div>

            <button id="start-btn" class="btn large hidden" onclick="startGame()">‚ñ∂Ô∏è Lancer la partie</button>
            <div id="waiting-div" class="waiting hidden">
                <div class="spinner"></div>
                <p>En attente de l'h√¥te...</p>
            </div>
        </div>

        <!-- LEVEL TRANSITION -->
        <div id="level-transition-screen" class="screen hidden">
            <div style="text-align: center;">
                <h1 style="font-size: 4rem; color: #ffbe0b; margin-bottom: 2rem; text-shadow: 0 0 30px rgba(255,190,11,0.5);">
                    üéØ NIVEAU <span id="next-level-num">2</span>
                </h1>
                <p style="font-size: 1.5rem; color: #00f5ff;" id="level-desc">Questions normales</p>
                <div class="spinner" style="margin: 3rem auto;"></div>
            </div>
        </div>

        <!-- MODE START COUNTDOWN (10s) -->
        <div id="mode-start-screen" class="screen hidden">
            <div style="text-align: center;">
                <h1 style="font-size: 4rem; color: #00f5ff; margin-bottom: 2rem; text-shadow: 0 0 30px rgba(0,245,255,0.5);" id="mode-start-title">
                    üéÆ MODE QCM
                </h1>
                <div style="font-size: 8rem; color: #ffbe0b; font-weight: 800; text-shadow: 0 0 50px rgba(255,190,11,0.8);" id="countdown-number">
                    10
                </div>
                <p style="font-size: 1.5rem; color: white; margin-top: 2rem;">Pr√©parez-vous...</p>
            </div>
        </div>

        <!-- QCM INTRO (unique) -->
        <div id="qcm-intro-screen" class="screen hidden">
            <div style="text-align: center; max-width: 700px; margin: 0 auto;">
                <h1 style="font-size: 3.5rem; color: #00f5ff; margin-bottom: 2rem; text-shadow: 0 0 30px rgba(0,245,255,0.5);">
                    üéØ MODE QCM
                </h1>
                <div style="background: rgba(0, 245, 255, 0.1); border: 3px solid #00f5ff; border-radius: 20px; padding: 2rem;">
                    <p style="font-size: 1.8rem; color: white; font-weight: 800;">4 CHOIX DE R√âPONSE</p>
                </div>
                <div class="spinner" style="margin: 3rem auto;"></div>
            </div>
        </div>

        <!-- WRITING LEVEL 1 INTRO -->
        <div id="writing-lvl1-intro-screen" class="screen hidden">
            <div style="text-align: center; max-width: 700px; margin: 0 auto;">
                <h1 style="font-size: 3.5rem; color: #ff006e; margin-bottom: 2rem; text-shadow: 0 0 30px rgba(255,0,110,0.5);">
                    ‚úçÔ∏è MODE √âCRITURE
                </h1>
                <div style="background: rgba(255, 0, 110, 0.1); border: 3px solid #ff006e; border-radius: 20px; padding: 2rem;">
                    <h2 style="color: #ffbe0b; font-size: 2.5rem; margin-bottom: 1.5rem;">NIVEAU 1</h2>
                    <p style="font-size: 1.5rem; color: white; font-weight: 800; margin-bottom: 1.5rem;">
                        TAPER LE NOM DE L'ARTISTE
                    </p>
                    <div style="background: rgba(255, 190, 11, 0.2); padding: 1rem; border-radius: 10px; margin-top: 1.5rem;">
                        <p style="font-size: 1.2rem; color: #ffbe0b; font-weight: 800;">üí° ASTUCE</p>
                        <p style="font-size: 1rem; color: white; margin-top: 0.5rem;">Orthographe tol√©rante !</p>
                        <p style="font-size: 1rem; color: white;">N'oubliez pas de valider avec Entr√©e</p>
                    </div>
                </div>
                <div class="spinner" style="margin: 3rem auto;"></div>
            </div>
        </div>

        <!-- WRITING LEVEL 2 INTRO -->
        <div id="writing-lvl2-intro-screen" class="screen hidden">
            <div style="text-align: center; max-width: 700px; margin: 0 auto;">
                <h1 style="font-size: 3.5rem; color: #ff006e; margin-bottom: 2rem; text-shadow: 0 0 30px rgba(255,0,110,0.5);">
                    ‚úçÔ∏è MODE √âCRITURE
                </h1>
                <div style="background: rgba(255, 0, 110, 0.1); border: 3px solid #ff006e; border-radius: 20px; padding: 2rem;">
                    <h2 style="color: #ffbe0b; font-size: 2.5rem; margin-bottom: 1.5rem;">NIVEAU 2</h2>
                    <p style="font-size: 1.5rem; color: white; font-weight: 800; margin-bottom: 1.5rem;">
                        TAPER LE TITRE ET LE NOM DE L'ARTISTE
                    </p>
                    <div style="background: rgba(255, 190, 11, 0.2); padding: 1rem; border-radius: 10px; margin-top: 1.5rem;">
                        <p style="font-size: 1.2rem; color: #ffbe0b; font-weight: 800;">üí° ASTUCE</p>
                        <p style="font-size: 1rem; color: white; margin-top: 0.5rem;">Orthographe tol√©rante !</p>
                        <p style="font-size: 1rem; color: white;">Un champ = une r√©ponse (titre OU artiste)</p>
                        <p style="font-size: 1rem; color: white;">Trouvez les 2 pour le bonus !</p>
                    </div>
                </div>
                <div class="spinner" style="margin: 3rem auto;"></div>
            </div>
        </div>

        <!-- WRITING TRANSITION (ancien, on garde pour compatibilit√©) -->
        <div id="writing-transition-screen" class="screen hidden">
            <div style="text-align: center; max-width: 600px; margin: 0 auto;">
                <h1 style="font-size: 3.5rem; color: #ff006e; margin-bottom: 2rem; text-shadow: 0 0 30px rgba(255,0,110,0.5);">
                    ‚úçÔ∏è MODE √âCRITURE
                </h1>
                <div style="background: rgba(255, 0, 110, 0.1); border: 3px solid #ff006e; border-radius: 20px; padding: 2rem; margin: 2rem 0;">
                    <h2 style="color: #ffbe0b; font-size: 2rem; margin-bottom: 1.5rem;">‚ö†Ô∏è ATTENTION</h2>
                    <p style="font-size: 1.3rem; color: white; margin-bottom: 1rem;">
                        üìù <strong>Orthographe PARFAITE requise !</strong>
                    </p>
                    <p style="font-size: 1.3rem; color: white; margin-bottom: 1rem;">
                        ‚úÖ <strong>N'oubliez pas de VALIDER votre r√©ponse !</strong>
                    </p>
                    <p style="font-size: 1rem; color: #aaa; margin-top: 1.5rem;">
                        (Les majuscules ne comptent pas)
                    </p>
                </div>
                <div class="spinner" style="margin: 3rem auto;"></div>
            </div>
        </div>

        <!-- MIX LEVEL 1 INTRO (Normal) -->
        <div id="mix-lvl1-intro-screen" class="screen hidden">
            <div style="text-align: center; max-width: 700px; margin: 0 auto;">
                <h1 style="font-size: 3.5rem; color: #00f5ff; margin-bottom: 2rem; text-shadow: 0 0 30px rgba(0,245,255,0.5);">
                    üéß MODE MIX
                </h1>
                <div style="background: rgba(0, 245, 255, 0.1); border: 3px solid #00f5ff; border-radius: 20px; padding: 2rem;">
                    <h2 style="color: #ffbe0b; font-size: 2.5rem; margin-bottom: 1rem;">NIVEAU 1 ‚Äî NORMAL</h2>
                    <p style="font-size: 1.5rem; color: white; font-weight: 800;">üéµ Extraits classiques</p>
                    <p style="font-size: 1.2rem; color: #aaa; margin-top: 0.8rem;">4 choix de r√©ponse</p>
                </div>
                <div class="spinner" style="margin: 3rem auto;"></div>
            </div>
        </div>

        <!-- MIX LEVEL 2 INTRO (Reverse) -->
        <div id="mix-lvl2-intro-screen" class="screen hidden">
            <div style="text-align: center; max-width: 700px; margin: 0 auto;">
                <h1 style="font-size: 3.5rem; color: #ff006e; margin-bottom: 2rem; text-shadow: 0 0 30px rgba(255,0,110,0.5);">
                    üéß MODE MIX
                </h1>
                <div style="background: rgba(255, 0, 110, 0.1); border: 3px solid #ff006e; border-radius: 20px; padding: 2rem;">
                    <h2 style="color: #ffbe0b; font-size: 2.5rem; margin-bottom: 1rem;">NIVEAU 2 ‚Äî REVERSE</h2>
                    <p style="font-size: 1.5rem; color: white; font-weight: 800;">‚è™ Musiques invers√©es !</p>
                    <p style="font-size: 1.2rem; color: #aaa; margin-top: 0.8rem;">4 choix de r√©ponse</p>
                </div>
                <div class="spinner" style="margin: 3rem auto;"></div>
            </div>
        </div>

        <!-- MIX LEVEL 3 INTRO (Extrait) -->
        <div id="mix-lvl3-intro-screen" class="screen hidden">
            <div style="text-align: center; max-width: 700px; margin: 0 auto;">
                <h1 style="font-size: 3.5rem; color: #ffbe0b; margin-bottom: 2rem; text-shadow: 0 0 30px rgba(255,190,11,0.5);">
                    üéß MODE MIX
                </h1>
                <div style="background: rgba(255, 190, 11, 0.1); border: 3px solid #ffbe0b; border-radius: 20px; padding: 2rem;">
                    <h2 style="color: #ff006e; font-size: 2.5rem; margin-bottom: 1rem;">NIVEAU 3 ‚Äî DIALOGUES</h2>
                    <p style="font-size: 1.5rem; color: white; font-weight: 800;">üé¨ Extraits de films !</p>
                    <p style="font-size: 1.2rem; color: #aaa; margin-top: 0.8rem;">Trouve le film parmi 4 propositions</p>
                </div>
                <div class="spinner" style="margin: 3rem auto;"></div>
            </div>
        </div>

        <!-- GAME -->
        <div id="game-screen" class="screen hidden">
            <div class="game-header">
                <div class="timer">‚è±Ô∏è <span id="timer">20</span>s <span id="level-badge" style="font-size:0.75rem; background:rgba(255,255,255,0.12); border-radius:6px; padding:2px 7px; margin-left:6px; color:#aaa;"></span></div>
                <div>Q <span id="current-q">1</span>/<span id="total-q">10</span></div>
                <div class="score">üèÜ <span id="player-score">0</span></div>
            </div>

            <div class="game-container">
                <!-- SCOREBOARD TEMPS R√âEL -->
                <div id="scoreboard-side" class="scoreboard-side">
                    <h3>üèÜ Scores</h3>
                    <div id="live-scores"></div>
                </div>

                <!-- GAME PRINCIPAL -->
                <div class="game-main">
                    <div class="img-box">
                        <img id="cover-img" class="cover" src="" alt="Cover">
                        <div id="answer-reveal" class="answer-reveal hidden">
                            <h4>R√©ponse :</h4>
                            <div class="answer-text" id="answer-text"></div>
                        </div>
                    </div>

                    <!-- Audio cach√© (pour mode distance) -->
                    <audio id="audio-player" loop style="display: none;"></audio>

                    <div class="question-box">
                        <h3 id="question-text" class="q-text"></h3>
                        <div id="options-container" class="options hidden"></div>
                        <div id="writing-container" class="hidden">
                            <!-- Badges de progression (affich√©s au-dessus) -->
                            <div id="writing-badges" style="display: flex; gap: 0.5rem; justify-content: center; margin-bottom: 1rem;">
                                <div id="badge-title" class="writing-badge" style="display: none;">
                                    <span class="badge-icon">üéµ</span>
                                    <span class="badge-label">TITRE</span>
                                    <span class="badge-status">‚úó</span>
                                </div>
                                <div id="badge-artist" class="writing-badge" style="display: none;">
                                    <span class="badge-icon">üé§</span>
                                    <span class="badge-label">ARTISTE</span>
                                    <span class="badge-status">‚úó</span>
                                </div>
                            </div>
                            
                            <!-- Un seul input -->
                            <input id="input-answer" class="input" placeholder="√âcris ta r√©ponse..." onkeypress="handleWritingEnter(event)">
                            <button class="btn" onclick="submitWriting()">Valider</button>
                        </div>
                        <div id="result-container" class="result hidden"></div>
                    </div>
                </div>

                <!-- BLOC DROITE : Joueurs qui ont bien r√©pondu (h√¥te uniquement, affich√© √† timer=0) -->
                <div id="correct-players-side" class="scoreboard-side hidden">
                    <h3>üéâ Bien r√©pondu !</h3>
                    <div id="correct-players-list"></div>
                </div>
            </div>
        </div>

        <!-- LEADERBOARD -->
        <div id="leaderboard-screen" class="screen hidden">
            <h1 class="leaderboard-title">üèÜ CLASSEMENT FINAL üèÜ</h1>
            <div id="podium-container" class="podium"></div>
            <div id="leaderboard-container" class="leaderboard"></div>
            
            <!-- Boutons de fin de partie -->
            <div id="leaderboard-buttons" style="display: flex; gap: 1rem; justify-content: center; margin-top: 2rem; flex-wrap: wrap;">
                <!-- Bouton pour l'H√îTE -->
                <button id="host-new-game-btn" class="btn large secondary hidden" onclick="goToCreate()">üéÆ Cr√©er une nouvelle partie</button>
                
                <!-- Bouton pour les JOUEURS -->
                <button id="player-rejoin-btn" class="btn large hidden" onclick="rejoinSameRoom()">üîÑ Rejouer (attendre l'h√¥te)</button>
                
                <!-- Bouton menu pour tout le monde -->
                <button class="btn large" onclick="restartGame()">üè† Menu principal</button>
            </div>
        </div>

        <!-- √âCRAN D'ATTENTE REJOIN -->
        <div id="waiting-rejoin-screen" class="screen hidden">
            <div style="text-align: center; max-width: 600px; margin: 0 auto;">
                <h1 style="font-size: 3rem; color: #00f5ff; margin-bottom: 2rem; text-shadow: 0 0 30px rgba(0,245,255,0.5);">
                    ‚è≥ En attente...
                </h1>
                
                <div style="background: rgba(0, 245, 255, 0.1); border: 3px solid #00f5ff; border-radius: 20px; padding: 2rem; margin-bottom: 2rem;">
                    <div class="spinner" style="margin: 0 auto 2rem;"></div>
                    
                    <p style="font-size: 1.5rem; color: white; font-weight: 800; margin-bottom: 1rem;">
                        L'h√¥te pr√©pare la prochaine partie
                    </p>
                    
                    <p style="font-size: 1.2rem; color: #aaa; margin-bottom: 1.5rem;">
                        Vous rejoindrez automatiquement d√®s que la partie sera cr√©√©e
                    </p>
                    
                    <div style="background: rgba(255, 190, 11, 0.2); padding: 1rem; border-radius: 10px;">
                        <p style="font-size: 1rem; color: #ffbe0b; font-weight: 800;">Code de la partie</p>
                        <p style="font-size: 2rem; color: white; font-weight: 800; margin-top: 0.5rem;" id="waiting-room-code">000000</p>
                    </div>
                </div>
                
                <button class="btn large secondary" onclick="cancelRejoin()">‚ùå Annuler et retourner au menu</button>
            </div>
        </div>

        <!-- BOUTON SECOURS -->
        <button id="emergency-btn" class="emergency-btn hidden" onclick="emergencyReset()">üè† MENU</button>
    </div>

    <!-- FIREBASE -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>

    <script>
        // ===========================================
        // CONFIG (√Ä d√©placer dans variables d'environnement pour production)
        // ===========================================
        const FIREBASE_CONFIG = {
            apiKey: "AIzaSyAWA-Zfs_hljCFz1wc0Rg2LJWZPINWONnU",
            authDomain: "quizz-party-ptg.firebaseapp.com",
            databaseURL: "https://quizz-party-ptg-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "quizz-party-ptg",
            storageBucket: "quizz-party-ptg.firebasestorage.app",
            messagingSenderId: "352511986737",
            appId: "1:352511986737:web:7318d807b4d3f3b6b29910"
        };

        firebase.initializeApp(FIREBASE_CONFIG);
        const db = firebase.database();

        // ===========================================
        // √âTAT GLOBAL
        // ===========================================
        let currentScreen = 'menu';
        let gameState = {
            room: null,
            playerIndex: 0,
            isHost: false,
            numQuestions: 10,
            musicDB: [],
            currentTime: 20,
            timerInterval: null,
            answered: false,
            roomRef: null,
            roomListeners: [],
            audioPlaying: false,
            hostDisplayOnly: false,
            distanceMode: false
        };
        
        // ===========================================
        // WAKE LOCK - Emp√™cher la mise en veille
        // ===========================================
        let wakeLock = null;

        async function requestWakeLock() {
            try {
                if ('wakeLock' in navigator) {
                    wakeLock = await navigator.wakeLock.request('screen');
                    console.log('‚úÖ Wake Lock activ√© - √©cran restera allum√©');
                    
                    wakeLock.addEventListener('release', () => {
                        console.log('‚ö†Ô∏è Wake Lock d√©sactiv√©');
                    });
                } else {
                    console.log('‚ö†Ô∏è Wake Lock API non support√©e sur ce navigateur');
                }
            } catch (err) {
                console.error('‚ùå Erreur Wake Lock:', err);
            }
        }

        function releaseWakeLock() {
            if (wakeLock !== null) {
                wakeLock.release();
                wakeLock = null;
                console.log('üîì Wake Lock lib√©r√©');
            }
        }

        // R√©activer le Wake Lock si l'utilisateur revient sur la page
        document.addEventListener('visibilitychange', async () => {
            if (wakeLock !== null && document.visibilityState === 'visible') {
                await requestWakeLock();
            }
        });

        // ===========================================
        // SESSION (reconnexion apr√®s rafra√Æchissement)
        // ===========================================
        function saveSession() {
            const session = {
                code: gameState.room.code,
                name: gameState.room.players[gameState.playerIndex].name,
                isHost: gameState.isHost
            };
            localStorage.setItem('quizPartySession', JSON.stringify(session));
        }

        function clearSession() {
            localStorage.removeItem('quizPartySession');
        }

        function tryReconnect() {
            const raw = localStorage.getItem('quizPartySession');
            if (!raw) return;

            let session;
            try { session = JSON.parse(raw); } catch(e) { clearSession(); return; }
            if (!session || !session.code || !session.name) { clearSession(); return; }

            console.log('üîÑ Session trouv√©e, tentative de reconnexion...', session);

            db.ref(`rooms/${session.code}`).once('value', snapshot => {
                const room = snapshot.val();

                // Room plus en vie sur Firebase
                if (!room) {
                    console.log('‚ùå Room introuvable, session effac√©e.');
                    clearSession();
                    return;
                }

                // Trouver le joueur par son nom
                const idx = room.players.findIndex(p => p.name === session.name);
                if (idx === -1) {
                    console.log('‚ùå Joueur introuvable dans la room.');
                    clearSession();
                    return;
                }

                // Partie termin√©e
                if (room.currentQ >= room.questions.length) {
                    console.log('‚úÖ Partie d√©j√† termin√©e.');
                    clearSession();
                    return;
                }

                // Tout bon ‚Äî on reconnecte
                console.log('‚úÖ Reconnexion r√©ussie !');
                gameState.room = room;
                gameState.playerIndex = idx;
                gameState.distanceMode = room.distanceMode || false;

                // V√©rifier depuis Firebase si c'est vraiment l'h√¥te (pas la session)
                gameState.isHost = (room.host === session.name);
                // hostDisplayOnly UNIQUEMENT si c'est l'h√¥te ET que le mode h√¥te est activ√©
                gameState.hostDisplayOnly = gameState.isHost && (room.hostMode || false);
                // Reconstruire musicDB depuis les questions (n√©cessaire pour g√©n√©rer les fausses r√©ponses QCM)
                gameState.musicDB = room.questions.map(q => ({
                    title: q.title,
                    artist: q.artist,
                    cover: q.cover,
                    preview: q.preview,
                    trackType: q.trackType || 'normal'
                }));

                if (room.started) {
                    // Partie en cours ‚Üí on BLOQUE sur la question suivante
                    gameState.waitingForNextQ = true;
                    gameState.lastSeenQ = room.currentQ; // On m√©morise la question actuelle
                    showScreen('game-screen');
                    document.getElementById('options-container').classList.add('hidden');
                    document.getElementById('writing-container').classList.add('hidden');
                    document.getElementById('question-text').textContent = '‚è≥ Attends la question suivante...';
                    document.getElementById('answer-reveal').classList.add('hidden');
                    document.getElementById('result-container').classList.add('hidden');
                    document.getElementById('timer').textContent = '‚Äî';
                    const coverBox = document.querySelector('.img-box');
                    if (coverBox) coverBox.style.display = 'none';
                    gameState.answered = true;
                    listenToRoom();
                } else {
                    // Pas encore lanc√©e ‚Üí on retourne au lobby
                    goToLobby();
                }
            });
        }
        // TON SERVEUR BACKEND !
        const BACKEND_URL = 'https://blind-test-ptg.vercel.app';

        async function fetchWithProxy(url) {
            // Plus besoin de proxies ! On utilise TON serveur !
            try {
                console.log('üîÑ Chargement via ton serveur...');
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const data = await response.json();
                console.log('‚úÖ Donn√©es charg√©es !');
                return data;
                
            } catch (error) {
                console.error('‚ùå Erreur:', error.message);
                throw new Error(`Erreur de chargement: ${error.message}`);
            }
        }

        async function getDeezerPlaylist(id) {
            try {
                console.log('üéµ Chargement playlist via TON serveur:', id);
                
                // Utiliser TON backend au lieu de l'API Deezer directement
                const data = await fetchWithProxy(`${BACKEND_URL}/api/deezer/playlist/${id}`);
                
                // V√©rifier que c'est un objet valide
                if (!data || !data.tracks || !data.tracks.data) {
                    throw new Error('Format de r√©ponse invalide');
                }
                
                const tracks = data.tracks.data
                    .filter(t => t && t.preview && t.album && t.album.cover_big && t.title && t.artist)
                    .map(t => ({
                        title: t.title,
                        artist: t.artist.name,
                        cover: t.album.cover_big,
                        preview: t.preview,
                        year: t.album.release_date ? new Date(t.album.release_date).getFullYear() : null
                    }));
                
                console.log(`‚úÖ ${tracks.length} morceaux charg√©s`);
                return tracks;
                
            } catch (error) {
                console.error('‚ùå Erreur Deezer:', error);
                throw new Error(`Impossible de charger la playlist.\n\nD√©tails: ${error.message}`);
            }
        }

        // Tester si une preview fonctionne
        async function testPreview(url) {
            return new Promise((resolve) => {
                const audio = new Audio(url);
                audio.addEventListener('canplaythrough', () => resolve(true), { once: true });
                audio.addEventListener('error', () => resolve(false), { once: true });
                audio.load();
                setTimeout(() => resolve(false), 3000); // Timeout 3s
            });
        }

        // Filtrer les musiques cass√©es
        async function filterWorkingTracks(tracks) {
            showLoading('Test des musiques...');
            const results = [];
            
            for (let i = 0; i < tracks.length; i++) {
                updateLoading(`Test ${i + 1}/${tracks.length}...`);
                const works = await testPreview(tracks[i].preview);
                if (works) {
                    results.push(tracks[i]);
                }
            }
            
            hideLoading();
            return results;
        }

        // ===========================================
        // UTILS
        // ===========================================
        function shuffle(arr) {
            // Fisher-Yates shuffle pour un vrai al√©atoire
            const shuffled = [...arr];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        function genCode() {
            // Essayer de r√©cup√©rer le code sauvegard√©
            const savedCode = localStorage.getItem('quiz_party_room_code');
            if (savedCode) {
                console.log('‚úÖ Code sauvegard√© trouv√©:', savedCode);
                return savedCode;
            }
            
            // Sinon, g√©n√©rer un nouveau code et le sauvegarder
            const newCode = Math.floor(100000 + Math.random() * 900000).toString();
            localStorage.setItem('quiz_party_room_code', newCode);
            console.log('‚úÖ Nouveau code g√©n√©r√© et sauvegard√©:', newCode);
            return newCode;
        }
        
        function changeRoomCode() {
            const newCode = Math.floor(100000 + Math.random() * 900000).toString();
            localStorage.setItem('quiz_party_room_code', newCode);
            alert(`‚úÖ Nouveau code g√©n√©r√© : ${newCode}\n\nCe code sera utilis√© pour vos prochaines parties.`);
            console.log('‚úÖ Code chang√©:', newCode);
        }

        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
            document.getElementById(screenId).classList.remove('hidden');
            currentScreen = screenId.replace('-screen', '');
            
            const emergency = document.getElementById('emergency-btn');
            if (screenId === 'menu-screen' || screenId === 'leaderboard-screen') {
                emergency.classList.add('hidden');
            } else {
                emergency.classList.remove('hidden');
            }
        }

        function showLoading(text) {
            document.getElementById('loading-text').textContent = text;
            document.getElementById('loading-overlay').classList.remove('hidden');
        }

        function updateLoading(text) {
            document.getElementById('loading-text').textContent = text;
        }

        function hideLoading() {
            document.getElementById('loading-overlay').classList.add('hidden');
        }

        // Fonction pour v√©rifier similarit√© (tol√©rance 1 lettre)
        function isSimilar(a, b) {
            a = a.toLowerCase().trim();
            b = b.toLowerCase().trim();
            
            if (a === b) return true;
            if (Math.abs(a.length - b.length) > 1) return false;
            
            let diff = 0;
            const maxLen = Math.max(a.length, b.length);
            
            for (let i = 0; i < maxLen; i++) {
                if (a[i] !== b[i]) diff++;
                if (diff > 1) return false;
            }
            
            return diff <= 1;
        }

        // ===========================================
        // NAVIGATION
        // ===========================================
        function goToMenu() {
            if (gameState.roomRef) gameState.roomRef.off();
            if (gameState.timerInterval) clearInterval(gameState.timerInterval);
            clearSession();
            
            // D√©sactiver le Wake Lock
            releaseWakeLock();
            
            gameState = {
                room: null,
                playerIndex: 0,
                isHost: false,
                numQuestions: 10,
                musicDB: [],
                currentTime: 20,
                timerInterval: null,
                answered: false,
                roomRef: null,
                roomListeners: [],
                audioPlaying: false,
                hostDisplayOnly: false,
                distanceMode: false
            };
            showScreen('menu-screen');
        }

        function goToCreate() {
            loadPlaylistsSelect();
            showScreen('create-screen');
            
            // Si on a d√©j√† une musicDB (partie pr√©c√©dente), la sauvegarder temporairement
            if (gameState.musicDB && gameState.musicDB.length > 0) {
                console.log(`üíæ Playlist pr√©c√©dente sauvegard√©e (${gameState.musicDB.length} tracks)`);
                // On garde gameState.musicDB pour le r√©utiliser
            }
        }

        function goToJoin() {
            showScreen('join-screen');
        }

        const PLAYLIST_PASSWORD = 'ElenaPTG'; // ‚Üê Change ce mot de passe

        function goToPlaylists() {
            const pwd = prompt('üîê Mot de passe pour g√©rer les playlists :');
            if (pwd === null) return; // annul√©
            if (pwd !== PLAYLIST_PASSWORD) {
                alert('‚ùå Mot de passe incorrect !');
                return;
            }
            loadPlaylists();
            loadJsonPlaylistsManager(); // Charger aussi les playlists JSON
            showScreen('playlists-screen');
        }

        function emergencyReset() {
            if (confirm('Retour au menu ? La partie en cours sera perdue.')) {
                goToMenu();
            }
        }

        // ===========================================
        // PLAYLISTS
        // ===========================================
        async function loadPlaylists() {
            const snapshot = await db.ref('playlists').once('value');
            const playlists = snapshot.val() || {};
            
            const container = document.getElementById('playlists-list');
            container.innerHTML = '';
            
            if (Object.keys(playlists).length === 0) {
                container.innerHTML = '<p style="color: #aaa; text-align: center;">Aucune playlist enregistr√©e</p>';
                return;
            }
            
            Object.entries(playlists).forEach(([id, playlist]) => {
                const div = document.createElement('div');
                div.className = 'playlist-item';
                div.innerHTML = `
                    <span class="playlist-name">${playlist.name}</span>
                    <span class="playlist-url">${playlist.url}</span>
                    <button class="btn danger" onclick="deletePlaylist('${id}')">üóëÔ∏è</button>
                `;
                container.appendChild(div);
            });
        }

        async function loadPlaylistsSelect() {
            const snapshot = await db.ref('playlists').once('value');
            const playlists = snapshot.val() || {};
            
            const select = document.getElementById('playlist-select');
            select.innerHTML = '<option value="">-- S√©lectionner --</option>';
            
            Object.entries(playlists).forEach(([id, playlist]) => {
                const option = document.createElement('option');
                option.value = playlist.url;
                option.textContent = playlist.name;
                select.appendChild(option);
            });
        }

        function showAddPlaylist() {
            document.getElementById('add-playlist-form').classList.remove('hidden');
        }

        async function savePlaylist() {
            const name = document.getElementById('new-playlist-name').value.trim();
            const url = document.getElementById('new-playlist-url').value.trim();
            
            if (!name || !url) {
                alert('‚ö†Ô∏è Remplis tous les champs !');
                return;
            }
            
            const match = url.match(/playlist\/(\d+)/);
            if (!match) {
                alert('‚ùå URL Deezer invalide !');
                return;
            }
            
            await db.ref('playlists').push({
                name,
                url,
                createdAt: Date.now()
            });
            
            alert('‚úÖ Playlist enregistr√©e !');
            document.getElementById('new-playlist-name').value = '';
            document.getElementById('new-playlist-url').value = '';
            document.getElementById('add-playlist-form').classList.add('hidden');
            loadPlaylists();
        }

        async function deletePlaylist(id) {
            if (confirm('Supprimer cette playlist ?')) {
                await db.ref(`playlists/${id}`).remove();
                loadPlaylists();
            }
        }

        // ===========================================
        // CREATE
        // ===========================================
        function selectNumQ(num) {
            gameState.numQuestions = num;
            document.querySelectorAll('.num-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
        }

        function switchPlaylistTab(tab) {
            const deezerTab = document.getElementById('deezer-tab');
            const savedTab = document.getElementById('saved-tab');
            const customTab = document.getElementById('custom-tab');
            const deezerBtn = document.getElementById('tab-deezer');
            const savedBtn = document.getElementById('tab-saved');
            const customBtn = document.getElementById('tab-custom');
            
            // Cacher tous les onglets
            deezerTab.style.display = 'none';
            savedTab.style.display = 'none';
            customTab.style.display = 'none';
            deezerBtn.style.background = 'rgba(255,255,255,0.1)';
            savedBtn.style.background = 'rgba(255,255,255,0.1)';
            customBtn.style.background = 'rgba(255,255,255,0.1)';
            
            // Afficher l'onglet s√©lectionn√©
            if (tab === 'deezer') {
                deezerTab.style.display = 'block';
                deezerBtn.style.background = '#ffbe0b';
            } else if (tab === 'saved') {
                savedTab.style.display = 'block';
                savedBtn.style.background = '#ffbe0b';
                refreshSavedPlaylistsList();
            } else if (tab === 'custom') {
                customTab.style.display = 'block';
                customBtn.style.background = '#ffbe0b';
            }
        }

        function saveCurrentPlaylist() {
            const jsonText = document.getElementById('custom-json').value.trim();
            if (!jsonText) {
                alert('‚ö†Ô∏è Colle d\'abord ton JSON dans le champ !');
                return;
            }
            
            try {
                const data = JSON.parse(jsonText);
                if (!data.playlist || !Array.isArray(data.playlist)) {
                    alert('‚ö†Ô∏è JSON invalide ! Il doit contenir une cl√© "playlist" avec un tableau.');
                    return;
                }
                
                const name = prompt('üìù Donne un nom √† cette playlist :\n(ex: "Disney Complet", "Ann√©es 80", "Hits 2023")');
                if (!name || name.trim() === '') return;
                
                // R√©cup√©rer les playlists existantes
                const saved = JSON.parse(localStorage.getItem('savedPlaylists') || '{}');
                
                // Sauvegarder
                saved[name.trim()] = {
                    data: data,
                    savedAt: new Date().toISOString(),
                    trackCount: data.playlist.length
                };
                
                localStorage.setItem('savedPlaylists', JSON.stringify(saved));
                
                alert(`‚úÖ Playlist "${name.trim()}" sauvegard√©e avec ${data.playlist.length} tracks !`);
                
                // Basculer vers l'onglet "Mes Playlists"
                switchPlaylistTab('saved');
                
            } catch (err) {
                alert('‚ö†Ô∏è Erreur : JSON invalide !');
            }
        }

        function refreshSavedPlaylistsList() {
            const select = document.getElementById('saved-playlist-select');
            const noPlaylistsMsg = document.getElementById('no-saved-playlists');
            const actions = document.getElementById('saved-playlist-actions');
            
            const saved = JSON.parse(localStorage.getItem('savedPlaylists') || '{}');
            const names = Object.keys(saved);
            
            // Vider le select
            select.innerHTML = '<option value="">-- S√©lectionner une playlist sauvegard√©e --</option>';
            
            if (names.length === 0) {
                noPlaylistsMsg.style.display = 'block';
                actions.style.display = 'none';
            } else {
                noPlaylistsMsg.style.display = 'none';
                names.forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    option.textContent = `${name} (${saved[name].trackCount} tracks)`;
                    select.appendChild(option);
                });
            }
        }

        function loadSavedPlaylist() {
            const select = document.getElementById('saved-playlist-select');
            const actions = document.getElementById('saved-playlist-actions');
            const name = select.value;
            
            if (!name) {
                actions.style.display = 'none';
                return;
            }
            
            actions.style.display = 'block';
            
            const saved = JSON.parse(localStorage.getItem('savedPlaylists') || '{}');
            const playlist = saved[name];
            
            if (!playlist) {
                alert('‚ö†Ô∏è Playlist introuvable !');
                return;
            }
            
            // Mettre le JSON dans le champ custom pour qu'il soit utilis√© lors du lancement
            document.getElementById('custom-json').value = JSON.stringify(playlist.data, null, 2);
        }

        function deleteSavedPlaylist() {
            const select = document.getElementById('saved-playlist-select');
            const name = select.value;
            
            if (!name) return;
            
            if (!confirm(`üóëÔ∏è Supprimer la playlist "${name}" ?\nCette action est irr√©versible.`)) {
                return;
            }
            
            const saved = JSON.parse(localStorage.getItem('savedPlaylists') || '{}');
            delete saved[name];
            localStorage.setItem('savedPlaylists', JSON.stringify(saved));
            
            alert(`‚úÖ Playlist "${name}" supprim√©e !`);
            refreshSavedPlaylistsList();
        }

        function loadJsonPlaylistsManager() {
            const container = document.getElementById('json-playlists-list');
            const noMsg = document.getElementById('no-json-playlists');
            
            const saved = JSON.parse(localStorage.getItem('savedPlaylists') || '{}');
            const names = Object.keys(saved);
            
            container.innerHTML = '';
            
            if (names.length === 0) {
                noMsg.style.display = 'block';
                return;
            }
            
            noMsg.style.display = 'none';
            
            names.forEach(name => {
                const playlist = saved[name];
                const div = document.createElement('div');
                div.className = 'playlist-item';
                div.innerHTML = `
                    <span class="playlist-name">${name}</span>
                    <span class="playlist-url">${playlist.trackCount} tracks</span>
                    <button class="btn danger" onclick="deleteJsonPlaylistFromManager('${name.replace(/'/g, "\\'")}')">üóëÔ∏è</button>
                `;
                container.appendChild(div);
            });
        }

        function deleteJsonPlaylistFromManager(name) {
            if (!confirm(`üóëÔ∏è Supprimer la playlist "${name}" ?\nCette action est irr√©versible.`)) {
                return;
            }
            
            const saved = JSON.parse(localStorage.getItem('savedPlaylists') || '{}');
            delete saved[name];
            localStorage.setItem('savedPlaylists', JSON.stringify(saved));
            
            alert(`‚úÖ Playlist "${name}" supprim√©e !`);
            loadJsonPlaylistsManager(); // Recharger la liste
        }

        async function loadAndCreate() {
            const name = document.getElementById('create-name').value.trim();
            const mode = document.getElementById('create-mode').value;
            const hostMode = document.getElementById('host-mode').checked;
            const distanceMode = document.getElementById('distance-mode').checked;
            
            if (!name) {
                alert('‚ö†Ô∏è Entre ton pseudo !');
                return;
            }
            
            // V√©rifier quel onglet est actif
            const customTab = document.getElementById('custom-tab');
            const savedTab = document.getElementById('saved-tab');
            const isCustomPlaylist = customTab.style.display !== 'none' || savedTab.style.display !== 'none';
            
            try {
                let tracks = [];
                
                if (isCustomPlaylist) {
                    // MODE PLAYLIST PERSO (JSON) ou PLAYLIST SAUVEGARD√âE
                    const jsonInput = document.getElementById('custom-json').value.trim();
                    
                    if (!jsonInput) {
                        alert('‚ö†Ô∏è S√©lectionne une playlist sauvegard√©e ou colle ton JSON !');
                        return;
                    }
                    
                    showLoading('Chargement de ta playlist...');
                    
                    // Parser le JSON
                    let data;
                    try {
                        data = JSON.parse(jsonInput);
                    } catch (e) {
                        throw new Error('JSON invalide ! V√©rifie qu\'il n\'y a pas d\'erreur de syntaxe.');
                    }
                    
                    // V√©rifier le format
                    if (!data.playlist || !Array.isArray(data.playlist)) {
                        throw new Error('Format JSON invalide ! Il doit contenir un tableau "playlist".');
                    }
                    
                    // Valider les musiques
                    tracks = data.playlist.filter(t => 
                        t.title && t.artist && t.preview && t.cover
                    ).map(t => ({
                        title: t.title,
                        artist: t.artist,
                        cover: t.cover,
                        preview: t.preview,
                        year: t.year || null,
                        trackType: t.trackType || 'normal'
                    }));
                    
                    if (tracks.length === 0) {
                        throw new Error('Aucune musique valide dans le JSON !');
                    }
                    
                    alert(`‚úÖ ${tracks.length} musiques charg√©es depuis ta playlist perso !`);
                    hideLoading();
                    
                } else {
                    // MODE DEEZER (comme avant)
                    let url = document.getElementById('playlist-select').value;
                    if (!url) {
                        url = document.getElementById('custom-playlist-url').value.trim();
                    }
                    
                    // Si pas d'URL et qu'on a d√©j√† une musicDB, la r√©utiliser
                    if (!url && gameState.musicDB && gameState.musicDB.length > 0) {
                        console.log(`üîÑ R√©utilisation de la playlist pr√©c√©dente (${gameState.musicDB.length} tracks)`);
                        tracks = gameState.musicDB;
                    } else if (!url) {
                        alert('‚ö†Ô∏è Choisis une playlist Deezer !');
                        return;
                    } else {
                        const match = url.match(/playlist\/(\d+)/);
                        if (!match) {
                            alert('‚ùå URL Deezer invalide !');
                            return;
                        }
                        
                        showLoading('Chargement des musiques Deezer...');
                        tracks = await getDeezerPlaylist(match[1]);
                        
                        showLoading(`${tracks.length} musiques charg√©es. Filtrage...`);
                        tracks = await filterWorkingTracks(tracks);
                        
                        if (tracks.length < gameState.numQuestions) {
                            alert(`‚ö†Ô∏è Seulement ${tracks.length} musiques valides. Ajuste le nombre de questions.`);
                            hideLoading();
                            return;
                        }
                        
                        alert(`‚úÖ ${tracks.length} musiques Deezer pr√™tes !`);
                        hideLoading();
                    }
                }
                
                // V√©rifier qu'on a assez de musiques
                if (tracks.length < gameState.numQuestions) {
                    alert(`‚ö†Ô∏è Ta playlist n'a que ${tracks.length} musiques. Ajuste le nombre de questions !`);
                    return;
                }
                
                createRoom(name, mode, tracks, hostMode, distanceMode);
                
            } catch (e) {
                hideLoading();
                alert('‚ùå Erreur : ' + e.message);
            }
        }

        // FONCTION: Cr√©er questions avec 2 niveaux UNIQUEMENT
        function createQuestionsWithLevels(tracks, numQuestions, mode) {
            const shuffled = shuffle(tracks);
            let questions = [];
            
            // R√âPARTITION PERSONNALIS√âE : Plus de Niveau 2
            let lvl1Count, lvl2Count;
            
            if (numQuestions === 5) {
                lvl1Count = 2; lvl2Count = 3;
            } else if (numQuestions === 10) {
                lvl1Count = 4; lvl2Count = 6;
            } else if (numQuestions === 15) {
                lvl1Count = 5; lvl2Count = 10;
            } else if (numQuestions === 20) {
                lvl1Count = 6; lvl2Count = 14;
            } else if (numQuestions === 25) {
                lvl1Count = 8; lvl2Count = 17;
            } else if (numQuestions === 30) {
                lvl1Count = 10; lvl2Count = 20;
            } else {
                // Pour autres nombres : ~40% Lvl1, ~60% Lvl2
                lvl1Count = Math.floor(numQuestions * 0.4);
                lvl2Count = numQuestions - lvl1Count;
            }
            
            console.log(`üìä R√©partition: ${lvl1Count} Lvl1 + ${lvl2Count} Lvl2`);
            
            let trackIndex = 0;
            
            if (mode === 'qcm') {
                // QCM : toutes les questions avec 4 choix
                const totalQcm = lvl1Count + lvl2Count; // Utiliser tout le quota
                for (let i = 0; i < totalQcm && trackIndex < shuffled.length; i++) {
                    questions.push({
                        ...shuffled[trackIndex++],
                        type: 'qcm',
                        level: 2,
                        qType: Math.random() > 0.5 ? 'artist' : 'title',
                        optionsCount: 4
                    });
                }
                
            } else if (mode === 'writing') {
                // === NIVEAU 1 : Artiste seulement ===
                for (let i = 0; i < lvl1Count && trackIndex < shuffled.length; i++) {
                    questions.push({
                        ...shuffled[trackIndex++],
                        type: 'writing',
                        level: 1,
                        askFor: 'artist'
                    });
                }
                
                // === NIVEAU 2 : Titre + Artiste ===
                for (let i = 0; i < lvl2Count && trackIndex < shuffled.length; i++) {
                    questions.push({
                        ...shuffled[trackIndex++],
                        type: 'writing',
                        level: 2,
                        askFor: 'both'
                    });
                }
                
            } else if (mode === 'soiree') {
                // MODE SOIR√âE : QCM D'ABORD, PUIS √âCRITURE
                // Structure : QCM (4 choix) ‚Üí √âcriture Lvl1 ‚Üí √âcriture Lvl2
                
                // Diviser en 2 : 50% QCM, 50% √âcriture
                const qcmTotal = Math.floor(numQuestions / 2);
                const writingTotal = numQuestions - qcmTotal;
                
                // R√©partition √âcriture : 40% Lvl1, 60% Lvl2
                const writingLvl1 = Math.floor(writingTotal * 0.4);
                const writingLvl2 = writingTotal - writingLvl1;
                
                console.log(`üìä Soir√©e: QCM(${qcmTotal}) + √âcriture(${writingLvl1}+${writingLvl2})`);
                
                // === QCM (4 choix uniquement) ===
                for (let i = 0; i < qcmTotal && trackIndex < shuffled.length; i++) {
                    questions.push({
                        ...shuffled[trackIndex++],
                        type: 'qcm',
                        level: 2,
                        mode: 'qcm',
                        qType: Math.random() > 0.5 ? 'artist' : 'title',
                        optionsCount: 4
                    });
                }
                
                // === √âCRITURE NIVEAU 1 ===
                for (let i = 0; i < writingLvl1 && trackIndex < shuffled.length; i++) {
                    questions.push({
                        ...shuffled[trackIndex++],
                        type: 'writing',
                        level: 1,
                        mode: 'writing', // Identifier le mode parent
                        askFor: 'artist'
                    });
                }
                
                // === √âCRITURE NIVEAU 2 ===
                for (let i = 0; i < writingLvl2 && trackIndex < shuffled.length; i++) {
                    questions.push({
                        ...shuffled[trackIndex++],
                        type: 'writing',
                        level: 2,
                        mode: 'writing',
                        askFor: 'both'
                    });
                }
                
            } else if (mode === 'mix') {
                // MODE MIX : Normal ‚Üí Reverse ‚Üí Dialogue
                const normalTracks = shuffle(tracks.filter(t => t.trackType === 'normal' || !t.trackType));
                const reverseTracks = shuffle(tracks.filter(t => t.trackType === 'reverse'));
                const dialogueTracks = shuffle(tracks.filter(t => t.trackType === 'dialogue'));

                // R√©partition personnalis√©e : 50% Normal, 20% Reverse, 30% Dialogue
                const lvl1Count = Math.round(numQuestions * 0.50);
                const lvl2Count = Math.round(numQuestions * 0.20);
                const lvl3Count = numQuestions - lvl1Count - lvl2Count;

                console.log(`üìä R√©partition: Lvl1(${lvl1Count}) Lvl2(${lvl2Count}) Lvl3(${lvl3Count})`);
                console.log(`üìä Disponible: Normal(${normalTracks.length}) Reverse(${reverseTracks.length}) Dialogue(${dialogueTracks.length})`);

                // V√©rifier qu'on a assez de tracks par type
                if (normalTracks.length < lvl1Count) {
                    alert(`‚ö†Ô∏è Pas assez de tracks Normal ! Tu as ${normalTracks.length} tracks mais il en faut ${lvl1Count}.\nAjoute des tracks "normal" dans ta playlist ou r√©duis le nombre de questions.`);
                    return [];
                }
                if (reverseTracks.length < lvl2Count) {
                    alert(`‚ö†Ô∏è Pas assez de tracks Reverse ! Tu as ${reverseTracks.length} tracks mais il en faut ${lvl2Count}.\nAjoute des tracks "reverse" dans ta playlist ou r√©duis le nombre de questions.`);
                    return [];
                }
                if (dialogueTracks.length < lvl3Count) {
                    alert(`‚ö†Ô∏è Pas assez de tracks Dialogue ! Tu as ${dialogueTracks.length} tracks mais il en faut ${lvl3Count}.\nAjoute des tracks "dialogue" dans ta playlist ou r√©duis le nombre de questions.`);
                    return [];
                }

                // === NIVEAU 1 : Normal ===
                for (let i = 0; i < lvl1Count; i++) {
                    questions.push({
                        ...normalTracks[i],
                        type: 'qcm',
                        level: 1,
                        mode: 'mix',
                        qType: 'artist',
                        optionsCount: 4
                    });
                }

                // === NIVEAU 2 : Reverse ===
                for (let i = 0; i < lvl2Count; i++) {
                    questions.push({
                        ...reverseTracks[i],
                        type: 'qcm',
                        level: 2,
                        mode: 'mix',
                        qType: 'artist',
                        optionsCount: 4
                    });
                }

                // === NIVEAU 3 : Dialogues ===
                for (let i = 0; i < lvl3Count; i++) {
                    questions.push({
                        ...dialogueTracks[i],
                        type: 'qcm',
                        level: 3,
                        mode: 'mix',
                        qType: 'artist',  // Pour dialogue, le nom du film est dans 'artist'
                        optionsCount: 4
                    });
                }

                console.log(`‚úÖ Questions g√©n√©r√©es: ${questions.length} total`);


            } else if (mode === 'qcm-film') {
                // MODE QCM FILM : comme QCM normal mais qType = 'artist' uniquement
                // Toutes les questions : 4 choix
                const totalQcmFilm = lvl1Count + lvl2Count;
                for (let i = 0; i < totalQcmFilm && trackIndex < shuffled.length; i++) {
                    questions.push({
                        ...shuffled[trackIndex++],
                        type: 'qcm',
                        level: 2,
                        mode: 'qcm-film',
                        qType: 'artist',
                        optionsCount: 4
                    });
                }

            } else {
                questions = shuffled.slice(0, numQuestions).map(q => ({
                    ...q,
                    type: 'qcm',
                    qType: 'title',
                    level: 2,
                    optionsCount: 4
                }));
            }
            
            // NE PAS M√âLANGER ! Garder l'ordre Lvl1 ‚Üí Lvl2
            return questions;
        }

        function createRoom(name, mode, tracks, hostMode, distanceMode) {
            const code = genCode();
            
            console.log(`üéÆ Cr√©ation de la room avec le code: ${code}`);
            
            gameState.musicDB = tracks;
            // hostDisplayOnly UNIQUEMENT pour l'h√¥te (pas les autres joueurs)
            gameState.hostDisplayOnly = hostMode && true; // true car on EST l'h√¥te ici
            gameState.distanceMode = distanceMode;
            
            const questions = createQuestionsWithLevels(tracks, gameState.numQuestions, mode);
            
            console.log(`‚úÖ Questions g√©n√©r√©es: ${questions.length}`);

            const room = {
                code,
                host: name,
                hostMode: hostMode,
                distanceMode: distanceMode,
                players: [{ name, score: 0, isHost: true }],
                questions,
                currentQ: 0,
                started: false
            };

            // Supprimer l'ancienne room si elle existe, puis cr√©er la nouvelle
            db.ref(`rooms/${code}`).remove().then(() => {
                console.log(`üóëÔ∏è Ancienne room ${code} supprim√©e`);
                return db.ref(`rooms/${code}`).set(room);
            }).then(() => {
                console.log(`‚úÖ Nouvelle room ${code} cr√©√©e avec ${questions.length} questions`);
                
                gameState.room = room;
                gameState.playerIndex = 0;
                gameState.isHost = true;
                
                saveSession();
                goToLobby();
            });
        }

        // ===========================================
        // JOIN
        // ===========================================
        function joinRoom() {
            const name = document.getElementById('join-name').value.trim();
            const code = document.getElementById('join-code').value.trim();

            if (!name) { alert('‚ö†Ô∏è Entre ton pseudo !'); return; }
            if (code.length !== 6) { alert('‚ö†Ô∏è Code invalide !'); return; }

            db.ref(`rooms/${code}`).once('value', snapshot => {
                const room = snapshot.val();
                
                if (!room) { alert('‚ùå Code invalide !'); return; }
                if (room.started) { alert('‚ùå Partie d√©j√† lanc√©e !'); return; }
                
                // V√©rifier si le pseudo existe d√©j√†
                const pseudoExists = room.players.some(p => p.name.toLowerCase() === name.toLowerCase());
                if (pseudoExists) {
                    alert('‚ùå Ce pseudo est d√©j√† pris ! Choisis-en un autre.');
                    return;
                }

                room.players.push({ name, score: 0 });
                db.ref(`rooms/${code}`).update({ players: room.players });

                gameState.room = room;
                gameState.playerIndex = room.players.length - 1;
                gameState.isHost = false;
                gameState.distanceMode = room.distanceMode || false;
                gameState.musicDB = room.questions;
                // Les joueurs qui rejoignent ne sont JAMAIS en mode display-only
                gameState.hostDisplayOnly = false;
                
                console.log('üë• Joueur rejoint - hostDisplayOnly forc√© √† false:', gameState.hostDisplayOnly);

                saveSession();
                goToLobby();
            });
        }

        // ===========================================
        // LOBBY
        // ===========================================
        function goToLobby() {
            showScreen('lobby-screen');
            
            document.getElementById('lobby-code').textContent = gameState.room.code;
            
            if (gameState.isHost) {
                document.getElementById('start-btn').classList.remove('hidden');
                document.getElementById('change-code-btn').classList.remove('hidden');
                document.getElementById('waiting-div').classList.add('hidden');
            } else {
                document.getElementById('start-btn').classList.add('hidden');
                document.getElementById('change-code-btn').classList.add('hidden');
                document.getElementById('waiting-div').classList.remove('hidden');
            }

            updatePlayersList();
            listenToRoom();
        }

        function updatePlayersList() {
            const list = document.getElementById('players-list');
            const count = document.getElementById('player-count');
            
            list.innerHTML = '';
            count.textContent = gameState.room.players.length;
            
            gameState.room.players.forEach((p, i) => {
                const div = document.createElement('div');
                div.className = 'player';
                div.innerHTML = `
                    <span class="player-num">${i + 1}</span>
                    <span class="player-name">${p.name}</span>
                    ${p.name === gameState.room.host ? '<span>üëë</span>' : ''}
                `;
                list.appendChild(div);
            });
        }

        // ======= OPTIMISATION FIREBASE : Listeners granulaires =======
        // Au lieu d'√©couter toute la room (~25KB par update),
        // on √©coute seulement les chemins qui changent (quelques bytes).
        // Questions (~20KB) charg√©es UNE SEULE FOIS au d√©marrage.
        // R√©duction estim√©e : ~90% de bande passante.

        function cleanupRoomListeners() {
            if (gameState.roomListeners) {
                gameState.roomListeners.forEach(ref => ref.off());
            }
            gameState.roomListeners = [];
        }

        function listenToRoom() {
            // Nettoyer les anciens listeners
            cleanupRoomListeners();
            // Compat avec l'ancien code qui fait gameState.roomRef.off()
            if (gameState.roomRef) gameState.roomRef.off();
            gameState.roomRef = { off: cleanupRoomListeners };

            const code = gameState.room.code;
            const roomBase = `rooms/${code}`;

            // Helper pour tracker les listeners
            function addListener(path, callback) {
                const ref = db.ref(path);
                ref.on('value', callback);
                gameState.roomListeners.push(ref);
                return ref;
            }

            // --- 1. LISTENER : started (1 boolean, quelques bytes) ---
            addListener(`${roomBase}/started`, snapshot => {
                const started = snapshot.val();
                gameState.room.started = started;

                if (started && currentScreen === 'lobby') {
                    // OPTIMISATION CL√â : D√©tacher le listener players
                    // En jeu, on utilise .once() au changement de question (pas de download continu)
                    if (gameState._playersListenerRef) {
                        gameState._playersListenerRef.off();
                        gameState.roomListeners = gameState.roomListeners.filter(r => r !== gameState._playersListenerRef);
                        gameState._playersListenerRef = null;
                        console.log('üîß Players listener d√©tach√© (passage au jeu - √©conomie de bande passante)');
                    }

                    // S'assurer que les questions sont charg√©es avant de d√©marrer
                    if (!gameState.room.questions || gameState.room.questions.length === 0) {
                        console.log('üì• Chargement des questions avant d√©marrage...');
                        db.ref(`${roomBase}/questions`).once('value', s => {
                            gameState.room.questions = s.val();
                            goToGame();
                        });
                    } else {
                        goToGame();
                    }
                }
            });

            // --- 2. LISTENER : players (LOBBY SEULEMENT) ---
            // D√©tach√© automatiquement quand le jeu d√©marre (voir listener started)
            // Pendant le jeu, on utilise .once() uniquement au changement de question
            // Si on est d√©j√† en jeu (reconnexion), on n'ajoute pas le listener
            if (currentScreen === 'lobby') {
                gameState._playersListenerRef = addListener(`${roomBase}/players`, snapshot => {
                    const players = snapshot.val();
                    if (!players) return;
                    gameState.room.players = players;
                    updatePlayersList();
                });
            } else {
                gameState._playersListenerRef = null;
            }

            // --- 3. LISTENER : currentQ (1 entier, quelques bytes) ‚Äî LE PLUS IMPORTANT ---
            addListener(`${roomBase}/currentQ`, snapshot => {
                const newCurrentQ = snapshot.val();
                if (newCurrentQ === null || newCurrentQ === undefined) return;

                const oldCurrentQ = gameState.room.currentQ;
                gameState.room.currentQ = newCurrentQ;

                if (currentScreen !== 'game') return;
                if (!gameState.room.questions) return;

                // CAS 1 : Attente apr√®s rafra√Æchissement
                if (gameState.waitingForNextQ) {
                    if (newCurrentQ !== gameState.lastSeenQ && newCurrentQ < gameState.room.questions.length) {
                        console.log('‚úÖ Nouvelle question d√©tect√©e apr√®s rafra√Æchissement, on reprend !');
                        gameState.waitingForNextQ = false;
                        gameState.lastSeenQ = null;
                        // Rafra√Æchir les scores avant d'afficher
                        db.ref(`${roomBase}/players`).once('value', s => {
                            gameState.room.players = s.val() || gameState.room.players;
                            loadQuestion();
                            updateScoreboard();
                        });
                    }
                    return;
                }

                // CAS 2 : Transition en cours
                if (gameState.transitionInProgress) return;

                // CAS 3 : Nouvelle question
                if (newCurrentQ !== oldCurrentQ && newCurrentQ < gameState.room.questions.length) {
                    console.log('üì¢ Nouvelle question:', newCurrentQ);
                    // Rafra√Æchir les scores avant d'afficher la nouvelle question
                    db.ref(`${roomBase}/players`).once('value', s => {
                        gameState.room.players = s.val() || gameState.room.players;
                        loadQuestion();
                        updateScoreboard();
                    });
                }

                // CAS 4 : Fin du jeu
                if (newCurrentQ >= gameState.room.questions.length) {
                    console.log('üèÅ Fin du jeu !');
                    // R√©cup√©rer les scores finaux
                    db.ref(`${roomBase}/players`).once('value', s => {
                        gameState.room.players = s.val() || gameState.room.players;
                        goToLeaderboard();
                    });
                }
            });

            // --- 4. LISTENER : newGameCode (pour redirection nouvelle partie) ---
            addListener(`${roomBase}/newGameCode`, snapshot => {
                const newGameCode = snapshot.val();
                if (!newGameCode || gameState.isHost) return;

                console.log('üîÑ Redirection vers nouvelle partie:', newGameCode);
                alert(`üéâ L'h√¥te a lanc√© une nouvelle partie !\nNouveau code : ${newGameCode}`);

                db.ref(`rooms/${newGameCode}`).once('value', newSnapshot => {
                    const newRoom = newSnapshot.val();
                    if (newRoom) {
                        const myName = gameState.room.players[gameState.playerIndex].name;
                        gameState.room = newRoom;
                        gameState.playerIndex = newRoom.players.findIndex(p => p.name === myName);
                        cleanupRoomListeners();
                        saveSession();
                        goToLobby();
                    }
                });
            });

            // --- 5. LISTENER : currentOptions (pour sync QCM entre joueurs) ---
            addListener(`${roomBase}/currentOptions`, snapshot => {
                const opts = snapshot.val();
                if (opts) {
                    gameState.room.currentOptions = opts;
                }
            });

            console.log(`üîß Listeners optimis√©s activ√©s pour room ${code} (5 listeners granulaires au lieu de 1 global)`);
        }

        function startGame() {
            db.ref(`rooms/${gameState.room.code}`).update({ started: true });
        }

        // ===========================================
        // GAME
        // ===========================================
        function goToGame() {
            // Activer le Wake Lock pour emp√™cher la mise en veille
            requestWakeLock();
            
            // Lancer avec compte √† rebours de 10 secondes
            startGameWithCountdown();
        }

        function loadQuestion() {
            const q = gameState.room.questions[gameState.room.currentQ];
            const player = gameState.room.players[gameState.playerIndex];

            // D√âTECTION CHANGEMENT DE MODE + NIVEAU (transitions pour TOUS les joueurs)
            const prevMode = gameState.lastMode || '';
            const prevLevel = gameState.lastLevel || 0;
            const currentMode = q.mode || q.type;
            const currentLevel = q.level || 2;
            
            let transitionScreen = null;

            // CAS 1 : Premi√®re question du jeu (prevMode === '')
            if (!prevMode) {
                if (currentMode === 'mix' && currentLevel === 1) {
                    transitionScreen = 'mix-lvl1-intro-screen';
                } else if (currentMode === 'qcm' || currentMode === 'qcm-film') {
                    transitionScreen = 'qcm-intro-screen';
                } else if (currentMode === 'writing' && currentLevel === 1) {
                    transitionScreen = 'writing-lvl1-intro-screen';
                }
            }

            // CAS 2 : Changement de mode en cours de jeu
            if (!transitionScreen && currentMode !== prevMode && prevMode) {
                if (currentMode === 'writing' && currentLevel === 1) {
                    transitionScreen = 'writing-lvl1-intro-screen';
                } else if (currentMode === 'qcm' || currentMode === 'qcm-film') {
                    transitionScreen = 'qcm-intro-screen';
                } else if (currentMode === 'mix' && currentLevel === 1) {
                    transitionScreen = 'mix-lvl1-intro-screen';
                }
            }
            
            // CAS 3 : Changement de niveau dans le m√™me mode (QCM n'a plus de niveaux)
            if (!transitionScreen && currentLevel !== prevLevel && prevLevel !== 0) {
                if (currentMode === 'writing' && currentLevel === 2) {
                    transitionScreen = 'writing-lvl2-intro-screen';
                } else if (currentMode === 'mix' && currentLevel === 2) {
                    transitionScreen = 'mix-lvl2-intro-screen';
                } else if (currentMode === 'mix' && currentLevel === 3) {
                    transitionScreen = 'mix-lvl3-intro-screen';
                }
            }

            if (transitionScreen) {
                gameState.lastMode = currentMode;
                gameState.lastLevel = currentLevel;
                gameState.usedQCMValues = []; // R√©initialiser les options utilis√©es √† chaque nouveau niveau
                gameState.transitionInProgress = true; // Bloquer le listener pendant la transition

                showScreen(transitionScreen);
                setTimeout(() => {
                    gameState.transitionInProgress = false;
                    // Recharger la room depuis Firebase pour avoir le bon currentQ
                    db.ref(`rooms/${gameState.room.code}`).once('value', snapshot => {
                        const freshData = snapshot.val();
                        if (freshData) {
                            gameState.room = freshData;
                            if (freshData.currentQ >= freshData.questions.length) {
                                goToLeaderboard();
                                return;
                            }
                        }
                        showScreen('game-screen');
                        loadQuestion();
                    });
                }, 3000);
                return;
            }
            
            gameState.lastMode = currentMode;
            gameState.lastLevel = currentLevel;

            // Timer : 30 secondes pour √©criture, 20 secondes pour QCM
            const timerDuration = q.type === 'qcm' ? 20 : 30;
            gameState.currentTime = timerDuration;
            gameState.timerDuration = timerDuration; // Stocker pour le calcul du blur
            gameState.answered = false;
            gameState.audioPlaying = false;
            gameState.pendingScore = 0;

            // Cacher le bloc "bien r√©pondu" √† droite
            document.getElementById('correct-players-side').classList.add('hidden');

            document.getElementById('current-q').textContent = gameState.room.currentQ + 1;
            document.getElementById('total-q').textContent = gameState.room.questions.length;
            document.getElementById('player-score').textContent = player.score || 0;
            document.getElementById('timer').textContent = timerDuration;

            // Badge niveau
            const lvlBadge = document.getElementById('level-badge');
            if (q.mode === 'mix') {
                const lvlLabels = { 1: 'üéµ Normal', 2: '‚è™ Reverse', 3: 'üé¨ Dialogues' };
                lvlBadge.textContent = lvlLabels[q.level] || '';
                lvlBadge.style.display = 'inline-block';
            } else {
                lvlBadge.style.display = 'none';
            }
            
            // COVER
            const coverBox = document.querySelector('.img-box');
            const coverImg = document.getElementById('cover-img');
            if (gameState.room.hostMode && !gameState.isHost) {
                coverBox.style.display = 'none';
            } else {
                // Rendre l'image compl√®tement invisible + blur max
                coverImg.style.visibility = 'hidden';
                coverImg.style.filter = 'blur(25px)';
                coverImg.style.opacity = '0';
                
                // Mettre un fond noir temporaire pour cacher le flash
                coverBox.style.background = '#000';
                
                coverImg.onload = function() {
                    // Attendre 50ms apr√®s le load pour √™tre s√ªr que le blur est appliqu√©
                    setTimeout(() => {
                        coverImg.style.visibility = 'visible';
                        coverImg.style.opacity = '1';
                        coverImg.style.filter = 'blur(25px)';
                        coverBox.style.background = '';
                    }, 50);
                };
                coverImg.src = q.cover;
                coverBox.style.display = 'block';
            }

            document.getElementById('answer-reveal').classList.add('hidden');
            document.getElementById('result-container').classList.add('hidden');

            // CACHER les r√©ponses ‚Äî on ne les montre qu'apr√®s que l'audio commence
            document.getElementById('options-container').classList.add('hidden');
            document.getElementById('writing-container').classList.add('hidden');

            updateScoreboard();

            // Audio (mode distance uniquement)
            const audio = document.getElementById('audio-player');
            
            if (gameState.distanceMode || gameState.isHost) {
                audio.src = q.preview;
                audio.load();
                
                if (gameState.distanceMode && gameState.isHost) {
                    const startTime = Date.now() + 500;
                    db.ref(`rooms/${gameState.room.code}/audioStartTime`).set(startTime);
                }
                
                setTimeout(() => {
                    if (gameState.distanceMode && !gameState.isHost) {
                        db.ref(`rooms/${gameState.room.code}/audioStartTime`).once('value', snapshot => {
                            const startTime = snapshot.val();
                            if (startTime) {
                                const delay = Math.max(0, startTime - Date.now());
                                setTimeout(() => {
                                    audio.play().catch(err => console.error('‚ùå Audio:', err));
                                }, delay);
                            } else {
                                audio.play().catch(err => console.error('‚ùå Audio:', err));
                            }
                        });
                    } else {
                        audio.play()
                            .then(() => {
                                console.log('‚úÖ Audio lanc√©');
                                gameState.audioPlaying = true;
                            })
                            .catch(err => {
                                console.error('‚ùå Erreur audio:', err);
                            });
                    }
                }, 500);
            }

            // Charger les options EN ARRI√àRE PLAN (pas encore visibles)
            if (q.type === 'qcm') {
                loadQCM(q);
                document.getElementById('options-container').classList.add('hidden');
            } else {
                loadWriting(q);
                document.getElementById('writing-container').classList.add('hidden');
            }

            // MODE H√îTE : ne pas afficher les questions, mais on a d√©j√† g√©n√©r√© les options ci-dessus
            console.log('üîç loadQuestion - isHost:', gameState.isHost, 'hostDisplayOnly:', gameState.hostDisplayOnly);
            
            if (gameState.hostDisplayOnly) {
                console.log('Mode Affichage H√¥te activ√© - pas de questions affich√©es');
                document.getElementById('question-text').textContent = '';
                startTimer();
                return;
            }

            console.log('‚úÖ Affichage normal des questions pour ce joueur');

            // R√âV√âLER les r√©ponses apr√®s 500ms (quand l'audio commence)
            setTimeout(() => {
                if (q.type === 'qcm') {
                    document.getElementById('options-container').classList.remove('hidden');
                } else {
                    document.getElementById('writing-container').classList.remove('hidden');
                }
            }, 500);

            startTimer();
        }

        function updateScoreboard() {
            const container = document.getElementById('live-scores');
            const scoreboard = document.getElementById('scoreboard-side');
            
            // Scoreboard visible SEULEMENT pour l'h√¥te ET si pas en mode distance
            if (!gameState.isHost || gameState.distanceMode) {
                scoreboard.style.display = 'none';
                return;
            }
            
            scoreboard.style.display = 'block';
            container.innerHTML = '';

            const sorted = [...gameState.room.players].sort((a, b) => {
                const scoreA = a.score || 0;
                const scoreB = b.score || 0;
                if (scoreB !== scoreA) return scoreB - scoreA;
                // D√©partage par timestamp
                return (a.lastAnswerTime || 0) - (b.lastAnswerTime || 0);
            });

            sorted.forEach(p => {
                // En mode h√¥te, ne pas afficher l'h√¥te dans le scoreboard
                if (gameState.room.hostMode && p.name === gameState.room.host) return;
                const div = document.createElement('div');
                div.className = 'score-item';
                if (p.name === gameState.room.players[gameState.playerIndex].name) {
                    div.classList.add('me');
                }
                div.innerHTML = `
                    <span class="score-name">${p.name}</span>
                    <span class="score-points">${p.score || 0}</span>
                `;
                container.appendChild(div);
            });
        }

        // Affiche les joueurs qui ont bien r√©pondu dans le bloc √† droite ‚Äî appel√©e une seule fois √† timer=0, uniquement h√¥te
        function showCorrectPlayers() {
            if (!gameState.isHost || gameState.distanceMode) return;

            const side = document.getElementById('correct-players-side');
            const list = document.getElementById('correct-players-list');

            // Lire lastAnswers depuis Firebase (donn√©es fra√Æches)
            db.ref(`rooms/${gameState.room.code}/lastAnswers`).once('value', snapshot => {
                const lastAnswers = snapshot.val() || {};
                const currentQ = gameState.room.currentQ;

                // Collecter les noms des joueurs qui ont bien r√©pondu
                const correctNames = [];
                gameState.room.players.forEach(p => {
                    const safeName = p.name.replace(/[.#$[\]]/g, '_');
                    const answer = lastAnswers[safeName];
                    if (answer && answer.questionIndex === currentQ && answer.correct) {
                        correctNames.push(p.name);
                    }
                });

                list.innerHTML = '';

                if (correctNames.length === 0) {
                    const msg = document.createElement('div');
                    msg.style.cssText = 'text-align:center; color:#aaa; padding:0.8rem 0; font-size:0.95rem;';
                    msg.textContent = 'üò¨ Personne cette fois !';
                    list.appendChild(msg);
                } else {
                    correctNames.forEach(name => {
                        const div = document.createElement('div');
                        div.style.cssText = 'background:rgba(0,200,100,0.2); border:1px solid #00c864; border-radius:8px; padding:0.5rem 0.7rem; margin-bottom:0.4rem; color:#fff; font-weight:600; font-size:0.9rem;';
                        div.textContent = '‚úÖ ' + name;
                        list.appendChild(div);
                    });
                }

                // Montrer le bloc
                side.classList.remove('hidden');
            });
        }

        function loadQCM(q) {
            const type = q.qType || 'title';
            const correct = q[type];
            
            // Texte de la question selon le contexte
            let questionText = '';
            if (q.mode === 'mix') {
                if (q.trackType === 'dialogue') {
                    questionText = 'üé¨ Quel est le film ?';
                } else {
                    questionText = 'üéµ Quel est le film ?';
                }
            } else if (q.mode === 'qcm-film') {
                questionText = 'üé¨ Quel est le film ?';
            } else {
                questionText = (type === 'artist' ? "Qui est l'artiste ?" : "Quel est le titre ?");
            }
            document.getElementById('question-text').textContent = questionText;

            // Si on a d√©j√† les options dans la room Firebase ‚Üí on les utilise directement
            const storedOptions = gameState.room.currentOptions;
            if (storedOptions && storedOptions.questionIndex === gameState.room.currentQ) {
                renderQCMOptions(storedOptions.options, correct);
                return;
            }

            // Si on n'est PAS l'h√¥te, attendre que l'h√¥te g√©n√®re les options
            if (!gameState.isHost) {
                const waitForOptions = setInterval(() => {
                    db.ref(`rooms/${gameState.room.code}/currentOptions`).once('value', snapshot => {
                        const opts = snapshot.val();
                        if (opts && opts.questionIndex === gameState.room.currentQ) {
                            clearInterval(waitForOptions);
                            renderQCMOptions(opts.options, correct);
                        }
                    });
                }, 200); // V√©rifier toutes les 200ms
                
                // Timeout de s√©curit√© apr√®s 3 secondes
                setTimeout(() => {
                    clearInterval(waitForOptions);
                }, 3000);
                return;
            }

            // UNIQUEMENT L'H√îTE g√©n√®re les options
            const allTracks = gameState.musicDB;

            // En mode mix, on filtre par trackType pour ne piger les fausses r√©ponses que dans le m√™me niveau
            let candidateTracks = allTracks;
            if (q.mode === 'mix' && q.trackType) {
                candidateTracks = allTracks.filter(t => t.trackType === q.trackType);
            }

            // Collecter les valeurs uniques disponibles comme fausses r√©ponses
            const wrongValues = [...new Set(
                candidateTracks
                    .map(t => t[type])
                    .filter(v => v && v !== correct)
            )];

            // Double shuffle pour plus d'al√©atoire
            const shuffledWrong = shuffle(shuffle(wrongValues));
            const targetCount = q.optionsCount || 4;
            
            console.log(`üé≤ Fausses r√©ponses disponibles: ${wrongValues.length}`);
            console.log(`üéØ Besoin de ${targetCount - 1} fausses r√©ponses`);
            
            // Si pas assez de fausses r√©ponses, prendre ce qu'on a
            if (shuffledWrong.length < targetCount - 1) {
                console.warn(`‚ö†Ô∏è Pas assez de fausses r√©ponses (${shuffledWrong.length}/${targetCount - 1})`);
            }
            
            // Prendre un subset al√©atoire (pas toujours les m√™mes)
            const neededCount = Math.min(shuffledWrong.length, targetCount - 1);
            const startIndex = Math.floor(Math.random() * Math.max(1, shuffledWrong.length - neededCount + 1));
            const selectedWrong = shuffledWrong.slice(startIndex, startIndex + neededCount);
            
            console.log(`‚úÖ S√©lectionn√©es: ${selectedWrong.length} fausses r√©ponses`);
            
            const options = [correct, ...selectedWrong];
            const shuffledOptions = shuffle(options);
            
            console.log(`üìã Options finales:`, shuffledOptions);

            // Sauvegarder dans Firebase pour que tous voient les m√™mes options
            db.ref(`rooms/${gameState.room.code}/currentOptions`).set({
                questionIndex: gameState.room.currentQ,
                options: shuffledOptions
            });

            renderQCMOptions(shuffledOptions, correct);
        }

        function renderQCMOptions(shuffledOptions, correct) {
            const container = document.getElementById('options-container');
            container.innerHTML = '';
            container.classList.remove('hidden');
            document.getElementById('writing-container').classList.add('hidden');

            shuffledOptions.forEach(opt => {
                const btn = document.createElement('button');
                btn.className = 'opt';
                btn.textContent = opt;
                btn.onclick = () => submitQCM(opt, correct);
                container.appendChild(btn);
            });

            gameState.correctAnswer = correct;
        }

        // G√©n√©rer variantes d'orthographe pour Lvl 3
        function loadWriting(q) {
            const level = q.level || 2;
            const askFor = q.askFor || 'both';
            
            document.getElementById('options-container').classList.add('hidden');
            document.getElementById('writing-container').classList.remove('hidden');
            
            const answerInput = document.getElementById('input-answer');
            const badgeTitle = document.getElementById('badge-title');
            const badgeArtist = document.getElementById('badge-artist');
            const submitBtn = document.querySelector('#writing-container .btn');
            
            // Vider et r√©activer l'input
            answerInput.value = '';
            answerInput.disabled = false;
            answerInput.style.opacity = '1';
            answerInput.style.cursor = 'text';
            answerInput.style.borderColor = '';
            answerInput.style.background = '';
            
            if (submitBtn) {
                submitBtn.disabled = false;
                submitBtn.style.opacity = '1';
                submitBtn.style.cursor = 'pointer';
            }
            
            // R√©initialiser les badges
            badgeTitle.classList.remove('found');
            badgeArtist.classList.remove('found');
            badgeTitle.querySelector('.badge-status').textContent = '‚úó';
            badgeArtist.querySelector('.badge-status').textContent = '‚úó';
            
            // IMPORTANT : R√©initialiser les points cumul√©s pour cette question
            gameState.currentQuestionPoints = 0;
            
            if (askFor === 'artist') {
                // LVL 1: Artiste seulement
                document.getElementById('question-text').textContent = "√âcris l'artiste (Facile)";
                badgeTitle.style.display = 'none';
                badgeArtist.style.display = 'inline-flex';
                answerInput.placeholder = "√âcris l'artiste...";
            } else if (askFor === 'both') {
                // LVL 2: Titre + Artiste
                document.getElementById('question-text').textContent = "√âcris le titre et l'artiste";
                badgeTitle.style.display = 'inline-flex';
                badgeArtist.style.display = 'inline-flex';
                answerInput.placeholder = "√âcris le titre ou l'artiste...";
            } else if (askFor === 'both_year') {
                // LVL 3: Titre + Artiste + Ann√©e
                document.getElementById('question-text').textContent = "√âcris le titre, l'artiste et l'ann√©e (Difficile)";
                badgeTitle.style.display = 'inline-flex';
                badgeArtist.style.display = 'inline-flex';
                answerInput.placeholder = "√âcris le titre, l'artiste et l'ann√©e...";
            }
            
            // Stocker le niveau dans gameState
            gameState.currentWritingLevel = {
                level,
                askFor,
                year: q.year,
                titleFound: false,
                artistFound: false
            };
            
            // AUTO-FOCUS sur l'input pour pouvoir √©crire directement
            setTimeout(() => {
                answerInput.focus();
            }, 100);
        }

        function startTimer() {
            if (gameState.timerInterval) clearInterval(gameState.timerInterval);

            gameState.timerInterval = setInterval(() => {
                gameState.currentTime--;
                document.getElementById('timer').textContent = gameState.currentTime;

                if (!gameState.answered) {
                    const maxTime = gameState.timerDuration || 20;
                    const blur = (gameState.currentTime / maxTime) * 25;
                    document.getElementById('cover-img').style.filter = `blur(${blur}px)`;
                }

                if (gameState.currentTime <= 0) {
                    clearInterval(gameState.timerInterval);
                    
                    document.getElementById('cover-img').style.filter = 'blur(0px)';
                    
                    const q = gameState.room.questions[gameState.room.currentQ];
                    
                    // BLOQUER LES INPUTS MODE √âCRITURE (emp√™che de valider apr√®s timer=0)
                    if (q.type === 'writing') {
                        disableWritingInputs();
                    }
                    
                    // AFFICHER LA R√âPONSE
                    document.getElementById('answer-text').textContent = `${q.title} - ${q.artist}`;
                    document.getElementById('answer-reveal').classList.remove('hidden');
                    
                    // AFFICHER LE FEEDBACK (QCM) - Sauf pour l'h√¥te en mode display-only
                    if (q.type === 'qcm' && gameState.answered && !gameState.hostDisplayOnly) {
                        const correct = q[q.qType];
                        document.querySelectorAll('.opt').forEach(btn => {
                            // Enlever le style jaune d'attente
                            btn.style.background = '';
                            btn.style.borderColor = '';
                            
                            // Mettre vert ou rouge
                            if (btn.textContent === correct) {
                                btn.classList.add('correct');
                            } else {
                                btn.classList.add('wrong');
                            }
                        });
                        
                        const pts = gameState.pendingScore || 0;
                        const isCorrect = gameState.pendingCorrect || false;
                        showResult(isCorrect, pts, `${q.title} - ${q.artist}`);
                    }
                    
                    // AFFICHER LE FEEDBACK (√âCRITURE) - Sauf pour l'h√¥te en mode display-only
                    if (q.type === 'writing' && !gameState.hostDisplayOnly) {
                        const levelInfo = gameState.currentWritingLevel || {};
                        
                        if (gameState.answered) {
                            // Compl√®tement r√©ussi (les 2 en niveau 2, ou l'artiste en niveau 1)
                            const pts = gameState.pendingScore || 0;
                            const isCorrect = gameState.pendingCorrect || false;
                            const feedback = gameState.pendingFeedback || '';
                            showResult(isCorrect, pts, `${q.title} - ${q.artist}`, feedback);
                        } else if (levelInfo.titleFound || levelInfo.artistFound) {
                            // Partiellement r√©ussi (seulement 1 sur 2 en niveau 2)
                            const totalPts = gameState.currentQuestionPoints || 0;
                            if (levelInfo.titleFound && !levelInfo.artistFound) {
                                showResult(true, 0, '', `üéµ Titre seulement : +${totalPts}pts`);
                            } else if (levelInfo.artistFound && !levelInfo.titleFound) {
                                showResult(true, 0, '', `üé§ Artiste seulement : +${totalPts}pts`);
                            }
                        } else {
                            // Rien trouv√©
                            showResult(false, 0, `${q.title} - ${q.artist}`);
                        }
                    }
                    
                    // DONNER LES POINTS MAINTENANT (seulement QCM et niveau 1 √©criture)
                    // Pour niveau 2 √©criture, les points sont d√©j√† donn√©s imm√©diatement
                    if (gameState.answered && gameState.pendingScore > 0) {
                        updateScore(gameState.pendingScore);
                        gameState.pendingScore = 0; // √âviter de redonner
                    }

                    // Afficher les joueurs qui ont bien r√©pondu (uniquement sur l'√©cran de l'h√¥te)
                    showCorrectPlayers();
                    
                    // Arr√™ter l'audio
                    if (gameState.distanceMode || gameState.isHost) {
                        document.getElementById('audio-player').pause();
                    }

                    if (gameState.isHost && !gameState.answered) {
                        gameState.answered = true;
                    }
                    
                    // ATTENDRE 5 SECONDES pour voir la r√©ponse
                    setTimeout(() => {
                        if (gameState.isHost) {
                            db.ref(`rooms/${gameState.room.code}/currentQ`).once('value', snapshot => {
                                const currentQ = snapshot.val();
                                db.ref(`rooms/${gameState.room.code}/currentQ`).set(currentQ + 1);
                            });
                        }
                    }, 5000); // 5 secondes au lieu de 2.5
                }
            }, 1000);
        }

        function submitQCM(answer, correct) {
            if (gameState.answered) return;
            gameState.answered = true;

            const isCorrect = answer === correct;
            const pts = isCorrect ? (50 + gameState.currentTime * 10) : 0;
            
            // STOCKER le score en attente (sera appliqu√© √† 0s)
            gameState.pendingScore = pts;
            gameState.pendingCorrect = isCorrect;
            gameState.pendingAnswer = answer; // Stocker la r√©ponse choisie

            // Pousser le r√©sultat dans Firebase pour que l'h√¥te puisse voir qui a bien r√©pondu
            const myName = gameState.room.players[gameState.playerIndex].name;
            db.ref(`rooms/${gameState.room.code}/lastAnswers/${myName.replace(/[.#$[\]]/g, '_')}`).set({
                correct: isCorrect,
                questionIndex: gameState.room.currentQ
            });
            
            // D√©sactiver les boutons + JAUNE sur celui choisi
            document.querySelectorAll('.opt').forEach(btn => {
                btn.classList.add('disabled');
                btn.onclick = null;
                
                // Mettre en JAUNE la r√©ponse choisie
                if (btn.textContent === answer) {
                    btn.style.background = 'rgba(255, 190, 11, 0.3)';
                    btn.style.borderColor = '#ffbe0b';
                }
            });
            
            // PAS de feedback imm√©diat ! Attendre 0s
        }

        function normalizeAnswer(text) {
            if (!text) return '';
            
            return text
                .toLowerCase()
                .trim()
                // Supprimer accents EN PREMIER (avant tout le reste)
                .normalize('NFD')
                .replace(/[\u0300-\u036f]/g, '')
                // Supprimer les articles
                .replace(/^(the|le|la|les|l'|un|une|des|a|an)\s+/gi, '')
                .replace(/\s+(the|le|la|les|l'|un|une|des|a|an)$/gi, '')
                // Supprimer ponctuation
                .replace(/['''`]/g, '')
                .replace(/[^\w\s]/g, '')
                // Normaliser espaces
                .replace(/\s+/g, ' ')
                .trim();
        }

        function levenshteinDistance(a, b) {
            if (!a || !b) return Math.max(a?.length || 0, b?.length || 0);
            
            const matrix = [];
            for (let i = 0; i <= b.length; i++) {
                matrix[i] = [i];
            }
            for (let j = 0; j <= a.length; j++) {
                matrix[0][j] = j;
            }
            
            for (let i = 1; i <= b.length; i++) {
                for (let j = 1; j <= a.length; j++) {
                    if (b.charAt(i - 1) === a.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }
            return matrix[b.length][a.length];
        }

        function isAnswerSimilar(input, correct) {
            const normalizedInput = normalizeAnswer(input);
            const normalizedCorrect = normalizeAnswer(correct);
            
            // Si vide, refuser
            if (!normalizedInput) {
                return { match: false, score: 0 };
            }
            
            // Exact match
            if (normalizedInput === normalizedCorrect) return { match: true, score: 1.0 };
            
            // Calcul Levenshtein
            const distance = levenshteinDistance(normalizedInput, normalizedCorrect);
            const maxLen = Math.max(normalizedInput.length, normalizedCorrect.length);
            const similarity = 1 - (distance / maxLen);
            
            // Syst√®me adaptatif selon la longueur TOTALE (pas par mot)
            let threshold;
            if (maxLen <= 4) {
                // Tr√®s courts (2-4 caract√®res) : tr√®s strict, 90% de similarit√©
                threshold = 0.90;
            } else if (maxLen <= 8) {
                // Moyens (5-8 caract√®res) : 85% de similarit√©
                threshold = 0.85;
            } else if (maxLen <= 15) {
                // Longs (9-15 caract√®res) : 80% de similarit√©
                threshold = 0.80;
            } else {
                // Tr√®s longs (16+ caract√®res) : 75% de similarit√©
                threshold = 0.75;
            }
            
            if (similarity >= threshold) {
                return { match: true, score: similarity };
            }
            
            return { match: false, score: similarity };
        }

        function showWritingFeedback(message, type) {
            // Cr√©er ou r√©cup√©rer l'√©l√©ment de feedback
            let feedbackEl = document.getElementById('writing-feedback');
            if (!feedbackEl) {
                feedbackEl = document.createElement('div');
                feedbackEl.id = 'writing-feedback';
                feedbackEl.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    padding: 1.5rem 2rem;
                    border-radius: 15px;
                    font-size: 1.5rem;
                    font-weight: bold;
                    z-index: 10000;
                    animation: fadeInOut 0.5s;
                `;
                document.body.appendChild(feedbackEl);
            }

            // Style selon le type
            if (type === 'success') {
                feedbackEl.style.background = 'rgba(0, 200, 100, 0.95)';
                feedbackEl.style.color = 'white';
                feedbackEl.style.border = '3px solid #00f5a0';
            } else if (type === 'error') {
                feedbackEl.style.background = 'rgba(255, 50, 50, 0.95)';
                feedbackEl.style.color = 'white';
                feedbackEl.style.border = '3px solid #ff6b6b';
            } else if (type === 'partial') {
                feedbackEl.style.background = 'rgba(255, 165, 0, 0.95)';
                feedbackEl.style.color = 'white';
                feedbackEl.style.border = '3px solid #ffa500';
            } else {
                feedbackEl.style.background = 'rgba(200, 200, 200, 0.95)';
                feedbackEl.style.color = '#333';
                feedbackEl.style.border = '3px solid #999';
            }

            feedbackEl.textContent = message;
            feedbackEl.style.display = 'block';

            // Cacher apr√®s 1.5 secondes (sauf pour les erreurs - 1 seconde)
            const delay = type === 'error' ? 1000 : 1500;
            setTimeout(() => {
                feedbackEl.style.display = 'none';
            }, delay);
        }

        function disableWritingInputs() {
            const answerInput = document.getElementById('input-answer');
            const submitBtn = document.querySelector('#writing-container .btn');
            
            if (answerInput) {
                answerInput.disabled = true;
                answerInput.style.opacity = '0.6';
                answerInput.style.cursor = 'not-allowed';
            }
            if (submitBtn) {
                submitBtn.disabled = true;
                submitBtn.style.opacity = '0.6';
                submitBtn.style.cursor = 'not-allowed';
            }
        }

        function handleWritingEnter(event) {
            // D√©tecte la touche Entr√©e (code 13 ou key 'Enter')
            if (event.key === 'Enter' || event.keyCode === 13) {
                event.preventDefault(); // Emp√™che le comportement par d√©faut
                submitWriting(); // Appelle la fonction de validation
            }
        }

        function submitWriting() {
            const q = gameState.room.questions[gameState.room.currentQ];
            const levelInfo = gameState.currentWritingLevel || { askFor: 'both', titleFound: false, artistFound: false };
            const userInput = document.getElementById('input-answer').value.trim();

            // VALIDATION de base
            if (!userInput) {
                showWritingFeedback('‚ö†Ô∏è Entre quelque chose !', 'warning');
                return;
            }

            // V√©rifier avec le nouveau syst√®me tol√©rant
            const titleResult = isAnswerSimilar(userInput, q.title);
            
            // Pour l'artiste, am√©liorer le split pour g√©rer les cas complexes
            // Exemples : "La Fouine, Kaaris" ou "Artist feat. Someone" ou "A & B"
            const artistString = q.artist || '';
            const artists = artistString
                .split(/[,&]|feat\.?|ft\.?/gi)  // Split par virgule, &, feat, feat., ft, ft.
                .map(a => a.trim())
                .filter(a => a.length > 0);  // Enlever les √©l√©ments vides
            
            console.log('üé§ Artistes d√©tect√©s:', artists);
            
            // V√©rifier si l'input correspond √† UN des artistes
            const artistResult = artists.some(a => isAnswerSimilar(userInput, a).match) 
                ? { match: true, score: 1.0 } 
                : isAnswerSimilar(userInput, artistString);  // Fallback : comparer avec la string compl√®te

            let titleOk = titleResult.match;
            let artistOk = artistResult.match;
            
            // NOUVEAU : V√©rifier si l'utilisateur a √©crit TITRE + ARTISTE en m√™me temps
            // Exemples : "Last Christmas Wham", "Wham Last Christmas", "Last Christmas - Wham"
            if (!titleOk || !artistOk) {
                // Essayer de s√©parer l'input en plusieurs parties
                const separators = [' - ', ' ‚Äì ', ' ‚Äî ', '  ']; // S√©parateurs courants
                let parts = [userInput]; // Par d√©faut, pas de s√©paration
                
                // Essayer chaque s√©parateur
                for (const sep of separators) {
                    if (userInput.includes(sep)) {
                        parts = userInput.split(sep).map(p => p.trim()).filter(p => p.length > 0);
                        break;
                    }
                }
                
                // Si pas de s√©parateur d√©tect√©, essayer de d√©couper par espaces (pour "Title Artist")
                if (parts.length === 1 && userInput.includes(' ')) {
                    const words = userInput.split(' ').filter(w => w.length > 0);
                    
                    // Tester diff√©rentes combinaisons
                    for (let i = 1; i < words.length; i++) {
                        const part1 = words.slice(0, i).join(' ');
                        const part2 = words.slice(i).join(' ');
                        
                        const p1Title = isAnswerSimilar(part1, q.title).match;
                        const p1Artist = artists.some(a => isAnswerSimilar(part1, a).match);
                        const p2Title = isAnswerSimilar(part2, q.title).match;
                        const p2Artist = artists.some(a => isAnswerSimilar(part2, a).match);
                        
                        // Si on trouve une combinaison valide
                        if ((p1Title && p2Artist) || (p1Artist && p2Title)) {
                            parts = [part1, part2];
                            break;
                        }
                    }
                }
                
                // V√©rifier chaque partie
                if (parts.length >= 2) {
                    for (const part of parts) {
                        if (!titleOk && isAnswerSimilar(part, q.title).match) {
                            titleOk = true;
                            console.log('üéµ Titre d√©tect√© dans:', part);
                        }
                        if (!artistOk && artists.some(a => isAnswerSimilar(part, a).match)) {
                            artistOk = true;
                            console.log('üé§ Artiste d√©tect√© dans:', part);
                        }
                    }
                }
            }

            // Mettre √† jour les badges
            const badgeTitle = document.getElementById('badge-title');
            const badgeArtist = document.getElementById('badge-artist');
            
            if (levelInfo.askFor === 'artist') {
                // ========== NIVEAU 1 : ARTISTE SEULEMENT ==========
                if (artistOk && !levelInfo.artistFound) {
                    levelInfo.artistFound = true;
                    badgeArtist.classList.add('found');
                    badgeArtist.querySelector('.badge-status').textContent = '‚úì';
                    
                    // Calculer les points pour l'artiste
                    const pts = 50 + gameState.currentTime * 10;
                    showWritingFeedback(`‚úÖ Correct ! +${pts}pts`, 'success');
                    
                    gameState.answered = true;
                    gameState.pendingScore = pts;
                    gameState.pendingCorrect = true;
                    
                    // Vider l'input et bloquer
                    document.getElementById('input-answer').value = '';
                    disableWritingInputs();
                    
                    // Pousser le r√©sultat dans Firebase
                    const myName = gameState.room.players[gameState.playerIndex].name;
                    db.ref(`rooms/${gameState.room.code}/lastAnswers/${myName.replace(/[.#$[\]]/g, '_')}`).set({
                        correct: true,
                        questionIndex: gameState.room.currentQ
                    });
                    
                    return;
                } else if (levelInfo.artistFound) {
                    // D√©j√† trouv√©
                    showWritingFeedback('‚úÖ D√©j√† trouv√© !', 'success');
                    document.getElementById('input-answer').value = '';
                    return;
                } else if (!artistOk) {
                    showWritingFeedback('‚ùå Faux, r√©essaye !', 'error');
                    document.getElementById('input-answer').value = '';
                    return;
                }
                
            } else if (levelInfo.askFor === 'both') {
                // ========== NIVEAU 2 : TITRE + ARTISTE (SYST√àME CUMULATIF) ==========
                let titleJustFound = false;
                let artistJustFound = false;
                let ptsGagnes = 0;
                
                // V√©rifier le TITRE (seulement si pas d√©j√† trouv√©)
                if (titleOk && !levelInfo.titleFound) {
                    levelInfo.titleFound = true;
                    titleJustFound = true;
                    badgeTitle.classList.add('found');
                    badgeTitle.querySelector('.badge-status').textContent = '‚úì';
                    
                    // Calculer les points pour le titre
                    const titlePts = 50 + gameState.currentTime * 10;
                    ptsGagnes += titlePts;
                    
                    // Stocker dans gameState pour les cumuler
                    if (!gameState.currentQuestionPoints) {
                        gameState.currentQuestionPoints = 0;
                    }
                    gameState.currentQuestionPoints += titlePts;
                    
                    console.log(`üéµ Titre trouv√© ! +${titlePts}pts`);
                }
                
                // V√©rifier l'ARTISTE (seulement si pas d√©j√† trouv√©)
                if (artistOk && !levelInfo.artistFound) {
                    levelInfo.artistFound = true;
                    artistJustFound = true;
                    badgeArtist.classList.add('found');
                    badgeArtist.querySelector('.badge-status').textContent = '‚úì';
                    
                    // Calculer les points pour l'artiste
                    const artistPts = 50 + gameState.currentTime * 10;
                    ptsGagnes += artistPts;
                    
                    // Stocker dans gameState pour les cumuler
                    if (!gameState.currentQuestionPoints) {
                        gameState.currentQuestionPoints = 0;
                    }
                    gameState.currentQuestionPoints += artistPts;
                    
                    console.log(`üé§ Artiste trouv√© ! +${artistPts}pts`);
                }
                
                // Vider l'input AVANT de g√©rer les feedbacks
                document.getElementById('input-answer').value = '';
                
                // G√©rer les diff√©rents cas
                if (titleJustFound && artistJustFound) {
                    // LES DEUX EN M√äME TEMPS ! üéâ
                    const bonus = 50;
                    const totalPts = gameState.currentQuestionPoints + bonus;
                    ptsGagnes += bonus;
                    
                    showWritingFeedback(`‚úÖ Parfait ! Les 2 en m√™me temps ! +${bonus}pts BONUS (Total: ${totalPts}pts)`, 'success');
                    
                    // Attribuer TOUS les points (titre + artiste + bonus)
                    updateScore(ptsGagnes);
                    
                    gameState.answered = true;
                    gameState.pendingScore = 0; // Points d√©j√† attribu√©s
                    gameState.pendingCorrect = true;
                    gameState.pendingFeedback = `‚úÖ Parfait ! Total: ${totalPts}pts`;
                    
                    disableWritingInputs();
                    
                    // Pousser le r√©sultat dans Firebase
                    const myName = gameState.room.players[gameState.playerIndex].name;
                    db.ref(`rooms/${gameState.room.code}/lastAnswers/${myName.replace(/[.#$[\]]/g, '_')}`).set({
                        correct: true,
                        questionIndex: gameState.room.currentQ
                    });
                    
                    // R√©initialiser pour la prochaine question
                    gameState.currentQuestionPoints = 0;
                    
                } else if (titleJustFound || artistJustFound) {
                    // UN SEUL TROUV√â (mais pas l'autre)
                    
                    // Afficher le bon feedback
                    if (titleJustFound && artistJustFound) {
                        // D√©j√† g√©r√© au-dessus
                    } else if (titleJustFound) {
                        showWritingFeedback(`üéµ Titre trouv√© ! +${ptsGagnes}pts`, 'success');
                    } else if (artistJustFound) {
                        showWritingFeedback(`üé§ Artiste trouv√© ! +${ptsGagnes}pts`, 'success');
                    }
                    
                    // Attribuer les points imm√©diatement
                    updateScore(ptsGagnes);
                    
                    // V√©rifier si les DEUX sont maintenant trouv√©s (cas o√π on trouve le 2√®me)
                    if (levelInfo.titleFound && levelInfo.artistFound) {
                        const bonus = 50;
                        const totalPts = gameState.currentQuestionPoints + bonus;
                        
                        showWritingFeedback(`‚úÖ Parfait ! Les 2 trouv√©s ! +${bonus}pts BONUS (Total: ${totalPts}pts)`, 'success');
                        
                        // Donner le bonus
                        updateScore(bonus);
                        
                        gameState.answered = true;
                        gameState.pendingScore = 0; // D√©j√† donn√©
                        gameState.pendingCorrect = true;
                        gameState.pendingFeedback = `‚úÖ Parfait ! Total: ${totalPts}pts`;
                        
                        disableWritingInputs();
                        
                        // Pousser le r√©sultat dans Firebase
                        const myName = gameState.room.players[gameState.playerIndex].name;
                        db.ref(`rooms/${gameState.room.code}/lastAnswers/${myName.replace(/[.#$[\]]/g, '_')}`).set({
                            correct: true,
                            questionIndex: gameState.room.currentQ
                        });
                        
                        // R√©initialiser pour la prochaine question
                        gameState.currentQuestionPoints = 0;
                    } else {
                        // Un seul trouv√© ‚Üí Continuer
                        gameState.answered = false; // Pas encore fini
                        document.getElementById('input-answer').placeholder = levelInfo.titleFound 
                            ? "Maintenant l'artiste..."
                            : "Maintenant le titre...";
                            
                        // Pousser dans Firebase qu'on a partiellement r√©pondu
                        const myName = gameState.room.players[gameState.playerIndex].name;
                        db.ref(`rooms/${gameState.room.code}/lastAnswers/${myName.replace(/[.#$[\]]/g, '_')}`).set({
                            correct: false, // Pas compl√®tement fini
                            partial: true,
                            questionIndex: gameState.room.currentQ
                        });
                    }
                    
                } else {
                    // RIEN DE NOUVEAU TROUV√â
                    if (levelInfo.titleFound && levelInfo.artistFound) {
                        showWritingFeedback('‚úÖ D√©j√† trouv√© les 2 !', 'success');
                    } else if (levelInfo.titleFound && titleOk) {
                        showWritingFeedback('üéµ Titre d√©j√† trouv√© ! Cherche l\'artiste', 'warning');
                    } else if (levelInfo.artistFound && artistOk) {
                        showWritingFeedback('üé§ Artiste d√©j√† trouv√© ! Cherche le titre', 'warning');
                    } else {
                        showWritingFeedback('‚ùå Faux, r√©essaye !', 'error');
                    }
                    return;
                }
                
            } else if (levelInfo.askFor === 'both_year') {
                // ========== NIVEAU 3 : TITRE + ARTISTE + ANN√âE (SYST√àME CUMULATIF) ==========
                let somethingNew = false;
                let ptsGagnes = 0;
                
                if (titleOk && !levelInfo.titleFound) {
                    levelInfo.titleFound = true;
                    badgeTitle.classList.add('found');
                    badgeTitle.querySelector('.badge-status').textContent = '‚úì';
                    
                    const titlePts = 50 + gameState.currentTime * 10;
                    ptsGagnes += titlePts;
                    
                    if (!gameState.currentQuestionPoints) {
                        gameState.currentQuestionPoints = 0;
                    }
                    gameState.currentQuestionPoints += titlePts;
                    
                    showWritingFeedback(`üéµ Titre trouv√© ! +${titlePts}pts`, 'success');
                    somethingNew = true;
                }
                
                if (artistOk && !levelInfo.artistFound) {
                    levelInfo.artistFound = true;
                    badgeArtist.classList.add('found');
                    badgeArtist.querySelector('.badge-status').textContent = '‚úì';
                    
                    const artistPts = 50 + gameState.currentTime * 10;
                    ptsGagnes += artistPts;
                    
                    if (!gameState.currentQuestionPoints) {
                        gameState.currentQuestionPoints = 0;
                    }
                    gameState.currentQuestionPoints += artistPts;
                    
                    showWritingFeedback(`üé§ Artiste trouv√© ! +${artistPts}pts`, 'success');
                    somethingNew = true;
                }
                
                if (!somethingNew) {
                    if (levelInfo.titleFound && titleOk) {
                        showWritingFeedback('üéµ Titre d√©j√† trouv√© !', 'warning');
                    } else if (levelInfo.artistFound && artistOk) {
                        showWritingFeedback('üé§ Artiste d√©j√† trouv√© !', 'warning');
                    } else {
                        showWritingFeedback('‚ùå Faux, r√©essaye !', 'error');
                    }
                    // VIDER L'INPUT m√™me si faux
                    document.getElementById('input-answer').value = '';
                    return;
                }
                
                // Attribuer les points IMM√âDIATEMENT
                if (ptsGagnes > 0) {
                    updateScore(ptsGagnes);
                }
                
                document.getElementById('input-answer').value = '';
                
                if (levelInfo.titleFound && levelInfo.artistFound) {
                    const bonus = 50;
                    const totalPts = gameState.currentQuestionPoints + bonus;
                    
                    showWritingFeedback(`‚úÖ Parfait ! +${bonus}pts BONUS (Total: ${totalPts}pts)`, 'success');
                    
                    updateScore(bonus);
                    
                    gameState.answered = true;
                    gameState.pendingScore = 0;
                    gameState.pendingCorrect = true;
                    gameState.pendingFeedback = `‚úÖ Parfait ! Total: ${totalPts}pts`;
                    
                    disableWritingInputs();
                    
                    const myName = gameState.room.players[gameState.playerIndex].name;
                    db.ref(`rooms/${gameState.room.code}/lastAnswers/${myName.replace(/[.#$[\]]/g, '_')}`).set({
                        correct: true,
                        questionIndex: gameState.room.currentQ
                    });
                    
                    gameState.currentQuestionPoints = 0;
                } else {
                    gameState.answered = false;
                    
                    const myName = gameState.room.players[gameState.playerIndex].name;
                    db.ref(`rooms/${gameState.room.code}/lastAnswers/${myName.replace(/[.#$[\]]/g, '_')}`).set({
                        correct: false,
                        partial: true,
                        questionIndex: gameState.room.currentQ
                    });
                }
            }
        }

        // VALIDATION AUTOMATIQUE en temps r√©el
        // Auto-validation supprim√©e - il faut cliquer sur Valider !

        function showResult(isCorrect, pts, answer, feedback = '') {
            const container = document.getElementById('result-container');
            container.classList.remove('hidden', 'correct', 'wrong');
            container.classList.add(isCorrect ? 'correct' : 'wrong');
            
            // Si correct ET que les points ont d√©j√† √©t√© donn√©s (pts = 0)
            if (isCorrect) {
                if (pts > 0) {
                    container.textContent = `üéâ ${feedback} +${pts} pts`;
                } else {
                    // Points d√©j√† donn√©s ‚Üí Afficher juste le feedback de succ√®s
                    container.textContent = feedback || `‚úÖ Correct !`;
                }
            } else {
                // Faux ‚Üí Afficher la r√©ponse
                container.textContent = `‚ùå ${answer}`;
            }
        }

        function updateScore(pts) {
            if (pts <= 0) return;
            
            const myName = gameState.room.players[gameState.playerIndex].name;
            const playersRef = db.ref(`rooms/${gameState.room.code}/players`);
            
            // Transaction atomique : lit, modifie, √©crit sans conflit
            playersRef.transaction(function(currentPlayers) {
                if (!currentPlayers) return currentPlayers;
                
                // Trouver mon index par mon NOM (pas par playerIndex)
                for (let i = 0; i < currentPlayers.length; i++) {
                    if (currentPlayers[i].name === myName) {
                        currentPlayers[i].score = (currentPlayers[i].score || 0) + pts;
                        // Ajouter un timestamp pour d√©partager les √©galit√©s
                        currentPlayers[i].lastAnswerTime = Date.now();
                        break;
                    }
                }
                
                return currentPlayers;
            });
        }

        function toggleAudio() {
            const audio = document.getElementById('audio-player');
            const btn = event.target;
            
            if (audio.paused) {
                audio.play();
                btn.textContent = 'üéµ Stop';
            } else {
                audio.pause();
                btn.textContent = 'üéµ Play';
            }
        }

        // ===========================================
        // LEADERBOARD
        // ===========================================
        function goToLeaderboard() {
            console.log('üèÜ LEADERBOARD');
            
            if (gameState.timerInterval) clearInterval(gameState.timerInterval);
            if (gameState.roomRef) gameState.roomRef.off();
            clearSession();

            showScreen('leaderboard-screen');

            const players = gameState.room.players || [];
            // Tri avec d√©partage : 1) Score d√©croissant, 2) Si √©galit√© ‚Üí temps de r√©ponse croissant (plus rapide = meilleur)
            let sorted = [...players].sort((a, b) => {
                const scoreA = a.score || 0;
                const scoreB = b.score || 0;
                
                // Si les scores sont diff√©rents, trier par score
                if (scoreB !== scoreA) {
                    return scoreB - scoreA;
                }
                
                // Si √©galit√© de score, d√©partager par timestamp (le plus petit = le plus rapide)
                const timeA = a.lastAnswerTime || 0;
                const timeB = b.lastAnswerTime || 0;
                return timeA - timeB;
            });

            // En mode h√¥te (affichage seulement), enlever l'h√¥te du classement
            if (gameState.room.hostMode) {
                sorted = sorted.filter(p => p.name !== gameState.room.host);
            }

            // Sauvegarder dans leaderboard all-time
            saveToAllTimeLeaderboard(sorted);

            const podium = document.getElementById('podium-container');
            podium.innerHTML = '';
            
            // Cr√©er le podium dans l'ordre 2√®me/1er/3√®me avec les bonnes classes
            const podiumClasses = ['first', 'second', 'third'];
            const medals = ['ü•á','ü•à','ü•â'];
            
            sorted.slice(0, 3).forEach((p, i) => {
                const div = document.createElement('div');
                div.className = `podium-item ${podiumClasses[i]}`;
                div.innerHTML = `
                    <div class="medal">${medals[i]}</div>
                    <div class="p-name">${p.name}</div>
                    <div class="p-score">${p.score || 0} pts</div>
                `;
                podium.appendChild(div);
            });

            const list = document.getElementById('leaderboard-container');
            list.innerHTML = '<h3 style="color: #00f5ff; margin-bottom: 0.8rem; text-align: center;">üéØ Cette partie</h3><div class="leaderboard-grid"></div>';
            
            const grid = list.querySelector('.leaderboard-grid');
            sorted.forEach((p, i) => {
                const div = document.createElement('div');
                div.className = 'lb-row';
                div.innerHTML = `
                    <span class="rank">#${i + 1}</span>
                    <span class="name">${p.name}</span>
                    <span class="pts">${p.score || 0} pts</span>
                `;
                grid.appendChild(div);
            });

            // Afficher all-time leaderboard
            displayAllTimeLeaderboard();
            
            // Afficher les bons boutons selon le r√¥le
            const hostBtn = document.getElementById('host-new-game-btn');
            const playerBtn = document.getElementById('player-rejoin-btn');
            
            if (gameState.isHost) {
                hostBtn.classList.remove('hidden');
                playerBtn.classList.add('hidden');
            } else {
                hostBtn.classList.add('hidden');
                playerBtn.classList.remove('hidden');
            }
        }

        async function saveToAllTimeLeaderboard(players) {
            for (const player of players) {
                if (player.score && player.score > 0) {
                    await db.ref('allTimeLeaderboard').push({
                        name: player.name,
                        score: player.score,
                        date: Date.now()
                    });
                }
            }
        }

        async function displayAllTimeLeaderboard() {
            const snapshot = await db.ref('allTimeLeaderboard')
                .orderByChild('score')
                .limitToLast(10)
                .once('value');
            
            const allTime = [];
            snapshot.forEach(child => {
                allTime.push(child.val());
            });
            
            allTime.reverse(); // Meilleurs en premier
            
            if (allTime.length > 0) {
                const container = document.getElementById('leaderboard-container');
                
                const titleDiv = document.createElement('h3');
                titleDiv.style.cssText = 'color: #ffbe0b; margin: 1.5rem 0 0.8rem; text-align: center;';
                titleDiv.textContent = 'üèÜ TOP 10 ALL-TIME';
                container.appendChild(titleDiv);
                
                // Cr√©er une grille pour all-time aussi
                const gridDiv = document.createElement('div');
                gridDiv.className = 'leaderboard-grid';
                
                allTime.forEach((entry, i) => {
                    const div = document.createElement('div');
                    div.className = 'lb-row';
                    div.style.background = 'rgba(255, 190, 11, 0.1)';
                    div.innerHTML = `
                        <span class="rank">#${i + 1}</span>
                        <span class="name">${entry.name}</span>
                        <span class="pts">${entry.score} pts</span>
                    `;
                    gridDiv.appendChild(div);
                });
                
                container.appendChild(gridDiv);
            }
        }

        function showIntroScreen(screenId) {
            showScreen(screenId);
            
            setTimeout(() => {
                showScreen('game-screen');
                loadQuestion();
            }, 3000); // 3 secondes
        }

        function startGameWithCountdown() {
            // V√©rifier que les questions existent
            if (!gameState.room.questions || gameState.room.questions.length === 0) {
                console.error('‚ùå Pas de questions disponibles !');
                alert('‚ùå Erreur : Aucune question n\'a √©t√© g√©n√©r√©e. Retour au menu.');
                goToMenu();
                return;
            }
            
            const q = gameState.room.questions[0];
            let modeTitle = 'üéÆ MODE QCM';
            if (q.mode === 'mix') {
                modeTitle = 'üéß MODE MIX';
            } else if (q.mode === 'writing' || q.type === 'writing') {
                modeTitle = '‚úçÔ∏è MODE √âCRITURE';
            } else if (q.mode === 'qcm-film') {
                modeTitle = 'üé¨ MODE QCM FILM';
            }
            
            document.getElementById('mode-start-title').textContent = modeTitle;
            showScreen('mode-start-screen');
            
            let countdown = 10;
            document.getElementById('countdown-number').textContent = countdown;
            
            const interval = setInterval(() => {
                countdown--;
                document.getElementById('countdown-number').textContent = countdown;
                
                if (countdown <= 0) {
                    clearInterval(interval);
                    showScreen('game-screen');
                    loadQuestion();
                }
            }, 1000);
        }

        function showLevelTransition(level) {
            const levelDesc = {
                1: 'Niveau Facile',
                2: 'Niveau Normal'
            };
            
            document.getElementById('next-level-num').textContent = level;
            document.getElementById('level-desc').textContent = levelDesc[level] || 'Niveau ' + level;
            
            showScreen('level-transition-screen');
            
            setTimeout(() => {
                showScreen('game-screen');
                loadQuestion(); // Charger la vraie question
            }, 3000); // 3 secondes de transition
        }

        function showWritingTransition() {
            showScreen('writing-transition-screen');
            
            setTimeout(() => {
                showScreen('game-screen');
                loadQuestion(); // Charger la vraie question
            }, 4000); // 4 secondes pour lire les instructions
        }

        function rejoinSameRoom() {
            // Le joueur veut rejouer dans la m√™me room
            // On garde son pseudo et le code de la room
            const playerName = gameState.room?.players[gameState.playerIndex]?.name;
            const roomCode = gameState.room?.code;
            
            if (!playerName || !roomCode) {
                alert('‚ùå Impossible de rejoindre. Retour au menu.');
                goToMenu();
                return;
            }
            
            // R√©initialiser gameState mais garder les infos essentielles
            const savedName = playerName;
            const savedCode = roomCode;
            
            clearSession();
            
            // Afficher l'√©cran d'attente au lieu de l'alert
            document.getElementById('waiting-room-code').textContent = savedCode;
            showScreen('waiting-rejoin-screen');
            
            // Attendre que la room soit recr√©√©e par l'h√¥te
            console.log(`üîÑ ${savedName} attend que l'h√¥te recr√©e la partie (code: ${savedCode})`);
            
            // Variable pour √©viter les rejoins multiples
            let hasRejoined = false;
            
            // √âcouter la room pour d√©tecter quand l'h√¥te recr√©e
            const roomRef = db.ref(`rooms/${savedCode}`);
            
            // Sauvegarder la r√©f√©rence pour pouvoir l'annuler
            gameState.waitingRoomRef = roomRef;
            
            // √âcouter les changements
            roomRef.on('value', snapshot => {
                const room = snapshot.val();
                
                if (!room) {
                    console.log(`‚è≥ ${savedName}: Room pas encore recr√©√©e...`);
                    return;
                }
                
                // √âviter les rejoins multiples
                if (hasRejoined) {
                    console.log(`‚ö†Ô∏è ${savedName}: D√©j√† rejoint, on ignore cet √©v√©nement`);
                    return;
                }
                
                // Si la room existe, n'a pas d√©marr√©, et a des questions (= nouvelle room cr√©√©e)
                if (!room.started && room.questions && room.questions.length > 0) {
                    console.log(`‚úÖ ${savedName}: Room d√©tect√©e ! Questions: ${room.questions.length}`);
                    
                    // Marquer qu'on a rejoint pour √©viter les doublons
                    hasRejoined = true;
                    
                    // Arr√™ter d'√©couter maintenant
                    roomRef.off();
                    
                    // V√©rifier si notre pseudo existe d√©j√†
                    const pseudoExists = room.players.some(p => p.name.toLowerCase() === savedName.toLowerCase());
                    
                    if (pseudoExists) {
                        console.log(`‚úÖ ${savedName}: Pseudo d√©j√† dans la room, reconnexion...`);
                        
                        // Rejoindre directement
                        gameState.room = room;
                        gameState.playerIndex = room.players.findIndex(p => p.name === savedName);
                        gameState.isHost = false;
                        gameState.hostDisplayOnly = false;
                        
                        console.log(`‚úÖ ${savedName}: playerIndex = ${gameState.playerIndex}`);
                        
                        saveSession();
                        goToLobby();
                        
                    } else {
                        console.log(`üîÑ ${savedName}: Rejoindre comme nouveau joueur...`);
                        
                        // Utiliser une transaction pour √©viter les conflits entre joueurs
                        db.ref(`rooms/${savedCode}/players`).transaction(currentPlayers => {
                            // Si pas de players, initialiser avec un array vide
                            if (!currentPlayers) {
                                console.log(`‚ö†Ô∏è ${savedName}: Pas de players, on initialise`);
                                return [{ name: savedName, score: 0, isHost: false }];
                            }
                            
                            // V√©rifier si le joueur existe d√©j√†
                            const exists = currentPlayers.some(p => p.name.toLowerCase() === savedName.toLowerCase());
                            
                            if (exists) {
                                console.log(`‚ö†Ô∏è ${savedName}: D√©j√† dans la liste, on garde tel quel`);
                                return currentPlayers; // Ne rien changer
                            }
                            
                            // Ajouter le nouveau joueur
                            console.log(`‚ûï ${savedName}: Ajout √† la liste (total: ${currentPlayers.length + 1})`);
                            return [...currentPlayers, { name: savedName, score: 0, isHost: false }];
                        }).then(() => {
                            console.log(`‚úÖ ${savedName}: Transaction r√©ussie, r√©cup√©ration de la room...`);
                            
                            // R√©cup√©rer la room mise √† jour
                            return db.ref(`rooms/${savedCode}`).once('value');
                        }).then(freshSnapshot => {
                            const freshRoom = freshSnapshot.val();
                            if (freshRoom) {
                                gameState.room = freshRoom;
                                gameState.playerIndex = freshRoom.players.findIndex(p => p.name === savedName);
                                gameState.isHost = false;
                                gameState.hostDisplayOnly = false;
                                
                                console.log(`‚úÖ ${savedName}: playerIndex = ${gameState.playerIndex}, total joueurs = ${freshRoom.players.length}`);
                                console.log(`üë• ${savedName}: Liste des joueurs:`, freshRoom.players.map(p => p.name));
                                
                                saveSession();
                                goToLobby();
                            }
                        }).catch(err => {
                            console.error(`‚ùå ${savedName}: Erreur lors du rejoin:`, err);
                            alert('‚ùå Erreur lors du rejoin. Retour au menu.');
                            goToMenu();
                        });
                    }
                } else {
                    console.log(`‚è≥ ${savedName}: Room existe mais pas pr√™te (started: ${room.started}, questions: ${room.questions?.length || 0})`);
                }
            });
        }

        function cancelRejoin() {
            // Arr√™ter d'√©couter Firebase
            if (gameState.waitingRoomRef) {
                gameState.waitingRoomRef.off();
                gameState.waitingRoomRef = null;
            }
            
            // Retour au menu
            goToMenu();
        }

        function restartGame() {
            goToMenu();
        }

        // ===========================================
        // INIT
        // ===========================================
        console.log('‚úÖ Quiz Party V2 charg√© !');
        tryReconnect(); // Tentative de reconnexion si rafra√Æchissement
    </script>
</body>
</html>
